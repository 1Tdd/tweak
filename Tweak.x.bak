#import <UIKit/UIKit.h>
#import <Foundation/Foundation.h>
#import <objc/runtime.h>
#import <objc/message.h> // For objc_msgSend
#import "SAMKeychain/AuthViewController.h"
#import "Colours/Colours.h"
#import "BHTManager.h"
#import <math.h>
#import "BHTBundle/BHTBundle.h"

// Forward declare T1ColorSettings and its private method to satisfy the compiler
@interface T1ColorSettings : NSObject
+ (void)_t1_applyPrimaryColorOption;
+ (void)_t1_updateOverrideUserInterfaceStyle; // Add this line
@end

// Forward declaration for the immersive view controller
@interface T1ImmersiveFullScreenViewController : UIViewController // Assuming base class, adjust if known
- (void)immersiveViewController:(id)immersiveViewController showHideNavigationButtons:(_Bool)showButtons;
// Declare other methods if their signatures are needed for direct calls or performSelector
- (void)playerViewController:(id)playerViewController playerStateDidChange:(NSInteger)state; // Assuming this method exists
@end

// Now declare the category, after the main interface is known
@interface T1ImmersiveFullScreenViewController (BHTwitter)
- (BOOL)BHT_findAndPrepareTimestampLabelForVC:(T1ImmersiveFullScreenViewController *)activePlayerVC; // Declare our new method
@end

// Forward declarations
static void BHT_UpdateAllTabBarIcons(void);
static void BHT_applyThemeToWindow(UIWindow *window);
static void BHT_ensureTheming(void);
static void BHT_forceRefreshAllWindowAppearances(void); // Renamed

// Map to store timestamp labels for each player instance
static NSMapTable<T1ImmersiveFullScreenViewController *, UILabel *> *playerToTimestampMap = nil;

// Static helper function for recursive view traversal - DEFINED AT THE TOP
static void BH_EnumerateSubviewsRecursively(UIView *view, void (^block)(UIView *currentView)) {
    if (!view || !block) return;
    block(view);
    for (UIView *subview in view.subviews) {
        BH_EnumerateSubviewsRecursively(subview, block);
    }
}

// Add this before the hooks, after the imports

UIColor *BHTCurrentAccentColor(void) {
    Class TAEColorSettingsCls = objc_getClass("TAEColorSettings");
    if (!TAEColorSettingsCls) {
        return [UIColor systemBlueColor];
    }

    id settings = [TAEColorSettingsCls sharedSettings];
    id current = [settings currentColorPalette];
    id palette = [current colorPalette];
    NSUserDefaults *defs = [NSUserDefaults standardUserDefaults];

    if ([defs objectForKey:@"bh_color_theme_selectedColor"]) {
        NSInteger opt = [defs integerForKey:@"bh_color_theme_selectedColor"];
        return [palette primaryColorForOption:opt] ?: [UIColor systemBlueColor];
    }

    if ([defs objectForKey:@"T1ColorSettingsPrimaryColorOptionKey"]) {
        NSInteger opt = [defs integerForKey:@"T1ColorSettingsPrimaryColorOptionKey"];
        return [palette primaryColorForOption:opt] ?: [UIColor systemBlueColor];
    }

    return [UIColor systemBlueColor];
}

static UIFont * _Nullable TAEStandardFontGroupReplacement(UIFont *self, SEL _cmd, CGFloat arg1, CGFloat arg2) {
    BH_BaseImp orig  = originalFontsIMP[NSStringFromSelector(_cmd)].pointerValue;
    NSUInteger nArgs = [[self class] instanceMethodSignatureForSelector:_cmd].numberOfArguments;
    UIFont *origFont;
    switch (nArgs) {
        case 2:
            origFont = orig(self, _cmd);
            break;
        case 3:
            origFont = orig(self, _cmd, arg1);
            break;
        case 4:
            origFont = orig(self, _cmd, arg1, arg2);
            break;
        default:
            // Should not be reachable, as it was verified before swizzling
            origFont = orig(self, _cmd);
            break;
    };
    
    UIFont *newFont  = BH_getDefaultFont(origFont);
    return newFont != nil ? newFont : origFont;
}
static void batchSwizzlingOnClass(Class cls, NSArray<NSString*>*origSelectors, IMP newIMP){
    for (NSString *sel in origSelectors) {
        SEL origSel = NSSelectorFromString(sel);
        Method origMethod = class_getInstanceMethod(cls, origSel);
        if (origMethod != NULL) {
            IMP oldImp = class_replaceMethod(cls, origSel, newIMP, method_getTypeEncoding(origMethod));
            [originalFontsIMP setObject:[NSValue valueWithPointer:oldImp] forKey:sel];
        } else {
            NSLog(@"[BHTwitter] Can't find method (%@) in Class (%@)", sel, NSStringFromClass(cls));
        }
    }
}

// MARK: Clean cache and Padlock
%hook T1AppDelegate
- (_Bool)application:(UIApplication *)application didFinishLaunchingWithOptions:(id)arg2 {
    %orig;
    if (![[NSUserDefaults standardUserDefaults] objectForKey:@"FirstRun_4.3"]) {
        [[NSUserDefaults standardUserDefaults] setValue:@"1strun" forKey:@"FirstRun_4.3"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"dw_v"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"hide_promoted"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"voice"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"undo_tweet"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"TrustedFriends"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"disableSensitiveTweetWarnings"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"disable_immersive_player"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"custom_voice_upload"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"dm_avatars"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"tab_bar_theming"];
    }
    [BHTManager cleanCache];
    if ([BHTManager FLEX]) {
        [[%c(FLEXManager) sharedManager] showExplorer];
    }
    
    // Apply theme on launch in a cleaner, more focused way
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
        
        // Directly set the theme in TAEColorSettings
        id taeSettings = [%c(TAEColorSettings) sharedSettings];
        if ([taeSettings respondsToSelector:@selector(setPrimaryColorOption:)]) {
            [taeSettings setPrimaryColorOption:selectedOption];
        }
        
        // Also update our internal color state
        BH_changeTwitterColor(selectedOption);
        
        // Schedule a delayed refresh to ensure UI elements catch up
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            // Force T1ColorSettings to refresh
            if ([%c(T1ColorSettings) respondsToSelector:@selector(_t1_applyPrimaryColorOption)]) {
                [%c(T1ColorSettings) _t1_applyPrimaryColorOption];
            }
            
            // Update UI elements that need specific handling
            BHT_forceRefreshAllWindowAppearances();
        });
    }
    
    return true;
}

- (void)applicationDidBecomeActive:(id)arg1 {
    %orig;
    
    // Only focus on theme refresh, not additional checks
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            // Just refresh what's needed - avoid redundant checks
            BHT_ensureTheming();
        });
    }

    if ([BHTManager Padlock]) {
        NSDictionary *keychainData = [[keychain shared] getData];
        if (keychainData != nil) {
            id isAuthenticated = [keychainData valueForKey:@"isAuthenticated"];
            if (isAuthenticated == nil || [isAuthenticated isEqual:@NO]) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    AuthViewController *auth = [[AuthViewController alloc] init];
                    [auth setModalPresentationStyle:UIModalPresentationFullScreen];
                    [self.window.rootViewController presentViewController:auth animated:true completion:nil];
                });
            }
        }
    }
}

- (void)applicationWillTerminate:(id)arg1 {
    %orig;
    if ([BHTManager Padlock]) {
        [[keychain shared] saveDictionary:@{@"isAuthenticated": @NO}];
    }
}

- (void)applicationWillResignActive:(id)arg1 {
    %orig;
    if ([BHTManager Padlock]) {
        UIImageView *image = [[UIImageView alloc] initWithFrame:self.window.bounds];
        [image setTag:909];
        [image setBackgroundColor:UIColor.systemBackgroundColor];
        [image setContentMode:UIViewContentModeCenter];
        [self.window addSubview:image];
    }
    if ([BHTManager FLEX]) {
        [[%c(FLEXManager) sharedManager] showExplorer];
    }
}
%end

// MARK: Custom Tab bar
%hook T1TabBarViewController
- (void)loadView {
    %orig;
    NSArray <NSString *> *hiddenBars = [BHCustomTabBarUtility getHiddenTabBars];
    for (T1TabView *tabView in self.tabViews) {
        if ([hiddenBars containsObject:tabView.scribePage]) {
            [tabView setHidden:true];
        }
    }
}

- (void)setTabBarHidden:(BOOL)arg1 withDuration:(CGFloat)arg2 {
    if ([BHTManager stopHidingTabBar]) {
        return;
    }
    
    return %orig;
}
- (void)setTabBarHidden:(BOOL)arg1 {
    if ([BHTManager stopHidingTabBar]) {
        return;
    }
    
    return %orig;
}

- (void)setTabBarOpacity:(double)opacity {
    if ([BHTManager stopHidingTabBar]) {
        %orig(1.0);
    } else {
        %orig(opacity);
    }
}

// Combined with stopHidingTabBar
- (void)setTabBarScrolling:(BOOL)scrolling {
    if ([BHTManager stopHidingTabBar]) {
        %orig(NO); // Force scrolling to NO if fading is prevented
    } else {
        %orig(scrolling);
    }
}
%end

%hook T1DirectMessageConversationEntriesViewController
- (void)viewDidLoad {
    %orig;
    if ([BHTManager changeBackground]) {
        if ([BHTManager backgroundImage]) { // set the backgeound as image
            NSFileManager *manager = [NSFileManager defaultManager];
            NSString *DocPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, true).firstObject;
            NSURL *imagePath = [[NSURL fileURLWithPath:DocPath] URLByAppendingPathComponent:@"msg_background.png"];
            
            if ([manager fileExistsAtPath:imagePath.path]) {
                UIImageView *backgroundImage = [[UIImageView alloc] initWithFrame:UIScreen.mainScreen.bounds];
                backgroundImage.image = [UIImage imageNamed:imagePath.path];
                [backgroundImage setContentMode:UIViewContentModeScaleAspectFill];
                [self.view insertSubview:backgroundImage atIndex:0];
            }
        }
        
        if ([[NSUserDefaults standardUserDefaults] objectForKey:@"background_color"]) { // set the backgeound as color
            NSString *hexCode = [[NSUserDefaults standardUserDefaults] objectForKey:@"background_color"];
            UIColor *selectedColor = [UIColor colorFromHexString:hexCode];
            self.view.backgroundColor = selectedColor;
        }
    }
}
%end

// MARK: Copy user information
%hook T1ProfileHeaderViewController
- (void)viewDidAppear:(_Bool)arg1 {
    %orig(arg1);
    if ([BHTManager CopyProfileInfo]) {
        T1ProfileHeaderView *headerView = [self valueForKey:@"_headerView"];
        UIView *innerContentView = [headerView.actionButtonsView valueForKey:@"_innerContentView"];
        UIButton *copyButton = [UIButton buttonWithType:UIButtonTypeCustom];
        [copyButton setImage:[UIImage systemImageNamed:@"doc.on.clipboard"] forState:UIControlStateNormal];
        if (@available(iOS 14.0, *)) {
            [copyButton setShowsMenuAsPrimaryAction:true];
            
            [copyButton setMenu:[UIMenu menuWithTitle:@"" children:@[
                [UIAction actionWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"COPY_PROFILE_INFO_MENU_OPTION_1"] image:[UIImage systemImageNamed:@"doc.on.clipboard"] identifier:nil handler:^(__kindof UIAction * _Nonnull action) {
                if (self.viewModel.bio != nil)
                    UIPasteboard.generalPasteboard.string = self.viewModel.bio;
            }],
                [UIAction actionWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"COPY_PROFILE_INFO_MENU_OPTION_2"] image:[UIImage systemImageNamed:@"doc.on.clipboard"] identifier:nil handler:^(__kindof UIAction * _Nonnull action) {
                if (self.viewModel.username != nil)
                    UIPasteboard.generalPasteboard.string = self.viewModel.username;
            }],
                [UIAction actionWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"COPY_PROFILE_INFO_MENU_OPTION_3"] image:[UIImage systemImageNamed:@"doc.on.clipboard"] identifier:nil handler:^(__kindof UIAction * _Nonnull action) {
                if (self.viewModel.fullName != nil)
                    UIPasteboard.generalPasteboard.string = self.viewModel.fullName;
            }],
                [UIAction actionWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"COPY_PROFILE_INFO_MENU_OPTION_4"] image:[UIImage systemImageNamed:@"doc.on.clipboard"] identifier:nil handler:^(__kindof UIAction * _Nonnull action) {
                if (self.viewModel.url != nil)
                    UIPasteboard.generalPasteboard.string = self.viewModel.url;
            }],
                [UIAction actionWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"COPY_PROFILE_INFO_MENU_OPTION_5"] image:[UIImage systemImageNamed:@"doc.on.clipboard"] identifier:nil handler:^(__kindof UIAction * _Nonnull action) {
                if (self.viewModel.location != nil)
                    UIPasteboard.generalPasteboard.string = self.viewModel.location;
            }],
            ]]];
            
        } else {
            [copyButton addTarget:self action:@selector(copyButtonHandler:) forControlEvents:UIControlEventTouchUpInside];
        }
        [copyButton setTintColor:UIColor.labelColor];
        [copyButton.layer setCornerRadius:32/2];
        [copyButton.layer setBorderWidth:1];
        [copyButton.layer setBorderColor:[UIColor colorFromHexString:@"2F3336"].CGColor];
        [copyButton setTranslatesAutoresizingMaskIntoConstraints:false];
        [headerView.actionButtonsView addSubview:copyButton];
        
        [NSLayoutConstraint activateConstraints:@[
            [copyButton.centerYAnchor constraintEqualToAnchor:headerView.actionButtonsView.centerYAnchor],
            [copyButton.widthAnchor constraintEqualToConstant:32],
            [copyButton.heightAnchor constraintEqualToConstant:32],
        ]];
        
        if (isDeviceLanguageRTL()) {
            [NSLayoutConstraint activateConstraints:@[
                [copyButton.leadingAnchor constraintEqualToAnchor:innerContentView.trailingAnchor constant:7],
            ]];
        } else {
            [NSLayoutConstraint activateConstraints:@[
                [copyButton.trailingAnchor constraintEqualToAnchor:innerContentView.leadingAnchor constant:-7],
            ]];
        }
    }
}
%new - (void)copyButtonHandler:(UIButton *)sender {
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"hi" message:nil preferredStyle:UIAlertControllerStyleActionSheet];
    if (is_iPad()) {
        alert.popoverPresentationController.sourceView = self.view;
        alert.popoverPresentationController.sourceRect = sender.frame;
    }
    UIAlertAction *bio = [UIAlertAction actionWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"COPY_PROFILE_INFO_MENU_OPTION_1"] style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        if (self.viewModel.bio != nil)
            UIPasteboard.generalPasteboard.string = self.viewModel.bio;
    }];
    UIAlertAction *username = [UIAlertAction actionWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"COPY_PROFILE_INFO_MENU_OPTION_2"] style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        if (self.viewModel.username != nil)
            UIPasteboard.generalPasteboard.string = self.viewModel.username;
    }];
    UIAlertAction *fullusername = [UIAlertAction actionWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"COPY_PROFILE_INFO_MENU_OPTION_3"] style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        if (self.viewModel.fullName != nil)
            UIPasteboard.generalPasteboard.string = self.viewModel.fullName;
    }];
    UIAlertAction *url = [UIAlertAction actionWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"COPY_PROFILE_INFO_MENU_OPTION_4"] style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        if (self.viewModel.url != nil)
            UIPasteboard.generalPasteboard.string = self.viewModel.url;
    }];
    UIAlertAction *location = [UIAlertAction actionWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"COPY_PROFILE_INFO_MENU_OPTION_5"] style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        if (self.viewModel.location != nil)
            UIPasteboard.generalPasteboard.string = self.viewModel.location;
    }];
    [alert addAction:bio];
    [alert addAction:username];
    [alert addAction:fullusername];
    [alert addAction:url];
    [alert addAction:location];
    [alert addAction:[UIAlertAction actionWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"CANCEL_BUTTON_TITLE"] style:UIAlertActionStyleCancel handler:nil]];
    [self presentViewController:alert animated:true completion:nil];
}
%end

%hook T1ProfileSummaryView
- (BOOL)shouldShowGetVerifiedButton {
    return [BHTManager hidePremiumOffer] ? false : %orig;
}
%end

// MARK: hide ADs
// credit goes to haoict https://github.com/haoict/twitter-no-ads
%hook TFNItemsDataViewController
- (id)tableViewCellForItem:(id)arg1 atIndexPath:(id)arg2 {
    UITableViewCell *_orig = %orig;
    id tweet = [self itemAtIndexPath:arg2];
    NSString *class_name = NSStringFromClass([tweet classForCoder]);
    
    if ([BHTManager HidePromoted] && [tweet respondsToSelector:@selector(isPromoted)] && [tweet performSelector:@selector(isPromoted)]) {
        [_orig setHidden:YES];
    }
    
    
    if ([self.adDisplayLocation isEqualToString:@"PROFILE_TWEETS"]) {
        if ([BHTManager hideWhoToFollow]) {
            if ([class_name isEqualToString:@"T1URTTimelineUserItemViewModel"] || [class_name isEqualToString:@"T1TwitterSwift.URTTimelineCarouselViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleHeaderViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleFooterViewModel"]) {
                [_orig setHidden:true];
            }
        }
        
        if ([BHTManager hideTopicsToFollow]) {
            if ([class_name isEqualToString:@"T1TwitterSwift.URTTimelineTopicCollectionViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleHeaderViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleFooterViewModel"] || [class_name isEqualToString:@"TwitterURT.URTTimelineCarouselViewModel"]) {
                [_orig setHidden:true];
            }
        }
    }
    
    if ([self.adDisplayLocation isEqualToString:@"OTHER"]) {
        if ([BHTManager HidePromoted] && ([class_name isEqualToString:@"TwitterURT.URTModuleHeaderViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleFooterViewModel"] || [class_name isEqualToString:@"T1URTTimelineMessageItemViewModel"])) {
            [_orig setHidden:true];
        }
        
        if ([BHTManager HidePromoted] && [class_name isEqualToString:@"TwitterURT.URTTimelineEventSummaryViewModel"]) {
            _TtC10TwitterURT32URTTimelineEventSummaryViewModel *trendModel = tweet;
            if ([[trendModel.scribeItem allKeys] containsObject:@"promoted_id"]) {
                [_orig setHidden:true];
            }
        }
        if ([BHTManager HidePromoted] && [class_name isEqualToString:@"TwitterURT.URTTimelineTrendViewModel"]) {
            _TtC10TwitterURT25URTTimelineTrendViewModel *trendModel = tweet;
            if ([[trendModel.scribeItem allKeys] containsObject:@"promoted_id"]) {
                [_orig setHidden:true];
            }
        }
        if ([BHTManager hideTrendVideos] && ([class_name isEqualToString:@"TwitterURT.URTModuleHeaderViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleFooterViewModel"] || [class_name isEqualToString:@"T1TwitterSwift.URTTimelineCarouselViewModel"])) {
            [_orig setHidden:true];
        }
    }
    
    if ([self.adDisplayLocation isEqualToString:@"TIMELINE_HOME"]) {
        if ([tweet isKindOfClass:%c(T1URTTimelineStatusItemViewModel)]) {
            T1URTTimelineStatusItemViewModel *fullTweet = tweet;
            if ([BHTManager HideTopics]) {
                if ((fullTweet.banner != nil) && [fullTweet.banner isKindOfClass:%c(TFNTwitterURTTimelineStatusTopicBanner)]) {
                    [_orig setHidden:true];
                }
            }
        }
        
        if ([BHTManager HideTopics]) {
            if ([tweet isKindOfClass:%c(_TtC10TwitterURT26URTTimelinePromptViewModel)]) {
                [_orig setHidden:true];
            }
        }

        if ([BHTManager hidePremiumOffer]) {
            if ([class_name isEqualToString:@"T1URTTimelineMessageItemViewModel"]) {
                [_orig setHidden:true];
            }
        }
    }
    
    return _orig;
}
- (double)tableView:(id)arg1 heightForRowAtIndexPath:(id)arg2 {
    id tweet = [self itemAtIndexPath:arg2];
    NSString *class_name = NSStringFromClass([tweet classForCoder]);
    
    if ([BHTManager HidePromoted] && [tweet respondsToSelector:@selector(isPromoted)] && [tweet performSelector:@selector(isPromoted)]) {
        return 0;
    }
    
    if ([self.adDisplayLocation isEqualToString:@"PROFILE_TWEETS"]) {
        if ([BHTManager hideWhoToFollow]) {
            if ([class_name isEqualToString:@"T1URTTimelineUserItemViewModel"] || [class_name isEqualToString:@"T1TwitterSwift.URTTimelineCarouselViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleHeaderViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleFooterViewModel"]) {
                return 0;
            }
        }
        if ([BHTManager hideTopicsToFollow]) {
            if ([class_name isEqualToString:@"T1TwitterSwift.URTTimelineTopicCollectionViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleHeaderViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleFooterViewModel"] || [class_name isEqualToString:@"TwitterURT.URTTimelineCarouselViewModel"]) {
                return 0;
            }
        }
    }
    
    if ([self.adDisplayLocation isEqualToString:@"OTHER"]) {
        if ([BHTManager HidePromoted] && ([class_name isEqualToString:@"TwitterURT.URTModuleHeaderViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleFooterViewModel"] || [class_name isEqualToString:@"T1URTTimelineMessageItemViewModel"])) {
            return 0;
        }
        
        if ([BHTManager HidePromoted] && [class_name isEqualToString:@"TwitterURT.URTTimelineEventSummaryViewModel"]) {
            _TtC10TwitterURT32URTTimelineEventSummaryViewModel *trendModel = tweet;
            if ([[trendModel.scribeItem allKeys] containsObject:@"promoted_id"]) {
                return 0;
            }
        }
        if ([BHTManager HidePromoted] && [class_name isEqualToString:@"TwitterURT.URTTimelineTrendViewModel"]) {
            _TtC10TwitterURT25URTTimelineTrendViewModel *trendModel = tweet;
            if ([[trendModel.scribeItem allKeys] containsObject:@"promoted_id"]) {
                return 0;
            }
        }

        if ([BHTManager hideTrendVideos] && ([class_name isEqualToString:@"TwitterURT.URTModuleHeaderViewModel"] || [class_name isEqualToString:@"TwitterURT.URTModuleFooterViewModel"] || [class_name isEqualToString:@"T1TwitterSwift.URTTimelineCarouselViewModel"])) {
            return 0;
        }
    }
    
    if ([self.adDisplayLocation isEqualToString:@"TIMELINE_HOME"]) {
        if ([tweet isKindOfClass:%c(T1URTTimelineStatusItemViewModel)]) {
            T1URTTimelineStatusItemViewModel *fullTweet = tweet;
            
            if ([BHTManager HideTopics]) {
                if ((fullTweet.banner != nil) && [fullTweet.banner isKindOfClass:%c(TFNTwitterURTTimelineStatusTopicBanner)]) {
                    return 0;
                }
            }
        }
        
        if ([BHTManager HideTopics]) {
            if ([tweet isKindOfClass:%c(_TtC10TwitterURT26URTTimelinePromptViewModel)]) {
                return 0;
            }
        }

        if ([BHTManager hidePremiumOffer]) {
            if ([class_name isEqualToString:@"T1URTTimelineMessageItemViewModel"]) {
                return 0;
            }
        }
    }
    
    return %orig;
}
- (double)tableView:(id)arg1 heightForHeaderInSection:(long long)arg2 {
    if (self.sections && self.sections[arg2] && ((NSArray* )self.sections[arg2]).count && self.sections[arg2][0]) {
        NSString *sectionClassName = NSStringFromClass([self.sections[arg2][0] classForCoder]);
        if ([sectionClassName isEqualToString:@"TFNTwitterUser"]) {
            return 0;
        }
    }
    return %orig;
}
%end

%hook TFNTwitterStatus
- (_Bool)isCardHidden {
    return ([BHTManager HidePromoted] && [self isPromoted]) ? true : %orig;
}
%end

// MARK: DM download
%hook T1DirectMessageEntryMediaCell
%property (nonatomic, strong) JGProgressHUD *hud;
- (void)setEntryViewModel:(id)arg1 {
    %orig;
    if ([BHTManager DownloadingVideos]) {
        UIContextMenuInteraction *menuInteraction = [[UIContextMenuInteraction alloc] initWithDelegate:self];
        [self setUserInteractionEnabled:true];
        
        if ([BHTManager isDMVideoCell:self.inlineMediaView]) {
            [self addInteraction:menuInteraction];
        }
    }
}
%new - (UIContextMenuConfiguration *)contextMenuInteraction:(UIContextMenuInteraction *)interaction configurationForMenuAtLocation:(CGPoint)location {
    return [UIContextMenuConfiguration configurationWithIdentifier:nil previewProvider:nil actionProvider:^UIMenu * _Nullable(NSArray<UIMenuElement *> * _Nonnull suggestedActions) {
        UIAction *saveAction = [UIAction actionWithTitle:@"Download" image:[UIImage systemImageNamed:@"square.and.arrow.down"] identifier:nil handler:^(__kindof UIAction * _Nonnull action) {
            [self DownloadHandler];
        }];
        return [UIMenu menuWithTitle:@"" children:@[saveAction]];
    }];
}
%new - (void)DownloadHandler {
    NSAttributedString *AttString = [[NSAttributedString alloc] initWithString:[[BHTBundle sharedBundle] localizedStringForKey:@"DOWNLOAD_MENU_TITLE"] attributes:@{
        NSFontAttributeName: [[%c(TAEStandardFontGroup) sharedFontGroup] headline2BoldFont],
        NSForegroundColorAttributeName: UIColor.labelColor
    }];
    TFNActiveTextItem *title = [[%c(TFNActiveTextItem) alloc] initWithTextModel:[[%c(TFNAttributedTextModel) alloc] initWithAttributedString:AttString] activeRanges:nil];
    
    NSMutableArray *actions = [[NSMutableArray alloc] init];
    [actions addObject:title];
    
    T1PlayerMediaEntitySessionProducible *session = self.inlineMediaView.viewModel.playerSessionProducer.sessionProducible;
    for (TFSTwitterEntityMediaVideoVariant *i in session.mediaEntity.videoInfo.variants) {
        if ([i.contentType isEqualToString:@"video/mp4"]) {
            TFNActionItem *download = [%c(TFNActionItem) actionItemWithTitle:[BHTManager getVideoQuality:i.url] imageName:@"arrow_down_circle_stroke" action:^{
                BHDownload *DownloadManager = [[BHDownload alloc] init];
                self.hud = [JGProgressHUD progressHUDWithStyle:JGProgressHUDStyleDark];
                self.hud.textLabel.text = [[BHTBundle sharedBundle] localizedStringForKey:@"PROGRESS_DOWNLOADING_STATUS_TITLE"];
                [DownloadManager downloadFileWithURL:[NSURL URLWithString:i.url]];
                [DownloadManager setDelegate:self];
                [self.hud showInView:topMostController().view];
            }];
            [actions addObject:download];
        }
        
        if ([i.contentType isEqualToString:@"application/x-mpegURL"]) {
            TFNActionItem *option = [objc_getClass("TFNActionItem") actionItemWithTitle:[[BHTBundle sharedBundle] localizedStringForKey:@"FFMPEG_DOWNLOAD_OPTION_TITLE"] imageName:@"arrow_down_circle_stroke" action:^{
                
                self.hud = [JGProgressHUD progressHUDWithStyle:JGProgressHUDStyleDark];
                self.hud.textLabel.text = [[BHTBundle sharedBundle] localizedStringForKey:@"FETCHING_PROGRESS_TITLE"];
                [self.hud showInView:topMostController().view];
                
                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                    MediaInformation *mediaInfo = [BHTManager getM3U8Information:[NSURL URLWithString:i.url]];
                    dispatch_async(dispatch_get_main_queue(), ^(void) {
                        [self.hud dismiss];

                        TFNMenuSheetViewController *alert2 = [BHTManager newFFmpegDownloadSheet:mediaInfo downloadingURL:[NSURL URLWithString:i.url] progressView:self.hud];
                        [alert2 tfnPresentedCustomPresentFromViewController:topMostController() animated:YES completion:nil];
                    });
                });
                
            }];
            
            [actions addObject:option];
        }
    }
    
    TFNMenuSheetViewController *alert = [[%c(TFNMenuSheetViewController) alloc] initWithActionItems:[NSArray arrayWithArray:actions]];
    [alert tfnPresentedCustomPresentFromViewController:topMostController() animated:YES completion:nil];
}
%new - (void)downloadProgress:(float)progress {
    self.hud.detailTextLabel.text = [BHTManager getDownloadingPersent:progress];
}

%new - (void)downloadDidFinish:(NSURL *)filePath Filename:(NSString *)fileName {
    NSString *DocPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, true).firstObject;
    NSFileManager *manager = [NSFileManager defaultManager];
    NSURL *newFilePath = [[NSURL fileURLWithPath:DocPath] URLByAppendingPathComponent:[NSString stringWithFormat:@"%@.mp4", NSUUID.UUID.UUIDString]];
    [manager moveItemAtURL:filePath toURL:newFilePath error:nil];
    [self.hud dismiss];
    [BHTManager showSaveVC:newFilePath];
}
%new - (void)downloadDidFailureWithError:(NSError *)error {
    if (error) {
        [self.hud dismiss];
    }
}
%end

// upload custom voice
%hook T1MediaAttachmentsViewCell
%property (nonatomic, strong) UIButton *uploadButton;
- (void)updateCellElements {
    %orig;

    if ([BHTManager customVoice]) {
        TFNButton *removeButton = [self valueForKey:@"_removeButton"];

        if ([self.attachment isKindOfClass:%c(TTMAssetVoiceRecording)]) {
            if (self.uploadButton == nil) {
                self.uploadButton = [UIButton buttonWithType:UIButtonTypeCustom];
                UIImageSymbolConfiguration *smallConfig = [UIImageSymbolConfiguration configurationWithScale:UIImageSymbolScaleSmall];
                UIImage *arrowUpImage = [UIImage systemImageNamed:@"arrow.up" withConfiguration:smallConfig];
                [self.uploadButton setImage:arrowUpImage forState:UIControlStateNormal];
                [self.uploadButton addTarget:self action:@selector(handleUploadButton:) forControlEvents:UIControlEventTouchUpInside];
                [self.uploadButton setTintColor:UIColor.labelColor];
                [self.uploadButton setBackgroundColor:[UIColor blackColor]];
                [self.uploadButton.layer setCornerRadius:29/2];
                [self.uploadButton setTranslatesAutoresizingMaskIntoConstraints:false];

                if (self.uploadButton.superview == nil) {
                    [self addSubview:self.uploadButton];
                    [NSLayoutConstraint activateConstraints:@[
                        [self.uploadButton.trailingAnchor constraintEqualToAnchor:removeButton.leadingAnchor constant:-10],
                        [self.uploadButton.topAnchor constraintEqualToAnchor:removeButton.topAnchor],
                        [self.uploadButton.widthAnchor constraintEqualToConstant:29],
                        [self.uploadButton.heightAnchor constraintEqualToConstant:29],
                    ]];
                }
            }
        }
    }
}
%new - (void)handleUploadButton:(UIButton *)sender {
    UIImagePickerController *videoPicker = [[UIImagePickerController alloc] init];
    videoPicker.mediaTypes = @[(NSString*)kUTTypeMovie];
    videoPicker.delegate = self;
    
    [topMostController() presentViewController:videoPicker animated:YES completion:nil];
}
%new - (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary<UIImagePickerControllerInfoKey,id> *)info {
    NSURL *videoURL = info[UIImagePickerControllerMediaURL];
    TTMAssetVoiceRecording *attachment = self.attachment;
    NSURL *recorder_url = [NSURL fileURLWithPath:attachment.filePath];
    
    if (recorder_url != nil) {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        
        NSError *error = nil;
        if ([fileManager fileExistsAtPath:[recorder_url path]]) {
            [fileManager removeItemAtURL:recorder_url error:&error];
            if (error) {
                NSLog(@"[BHTwitter] Error removing existing file: %@", error);
            }
        }
        
        [fileManager copyItemAtURL:videoURL toURL:recorder_url error:&error];
        if (error) {
            NSLog(@"[BHTwitter] Error copying file: %@", error);
        }
    }
    
    [picker dismissViewControllerAnimated:true completion:nil];
}
%new - (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker {
    [picker dismissViewControllerAnimated:true completion:nil];
}
%end


// MARK: Color theme
%hook TFNPagingViewController
- (void)viewDidAppear:(_Bool)animated {
    %orig(animated);
    
    // Re-apply theme when this controller appears
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        BHT_ensureTheming();
    }
}
%end

%hook TFNNavigationController
- (void)viewDidAppear:(_Bool)animated {
    %orig(animated);
    
    // Re-apply theme when this controller appears
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        BHT_ensureTheming();
    }
}
%end

%hook T1AppSplitViewController
- (void)viewDidAppear:(_Bool)animated {
    %orig(animated);
    
    // Re-apply theme when this controller appears
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        BHT_ensureTheming();
    }
}
%end

// Add a dedicated hook for Twitter's color settings class to ensure theme consistency
%hook TAEColorSettings

- (void)setPrimaryColorOption:(NSInteger)option {
    // Check if our theme is active, and ensure our value takes precedence
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
        %orig(selectedOption); // Apply our selected option instead
    } else {
        %orig; // Otherwise, let Twitter use its value
    }
}

- (void)applyCurrentColorPalette {
    %orig;
    
    // After Twitter applies its palette, ensure our theme is properly set
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
        // Update our styling but don't call orig again to avoid loops
        [self setPrimaryColorOption:selectedOption];
        BH_changeTwitterColor(selectedOption);
        // Notify Twitter color systems of the change
        if ([%c(T1ColorSettings) respondsToSelector:@selector(_t1_applyPrimaryColorOption)]) {
            [%c(T1ColorSettings) _t1_applyPrimaryColorOption];
        }
    }
}

// Intercept color changes from anywhere in the app
- (void)handleSettingsChange:(NSNotification *)notification {
    %orig;
    
    // Ensure our theme is applied after any settings change
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
            BH_changeTwitterColor(selectedOption);
        });
    }
}

%end

// Hook T1ColorSettings to ensure our changes propagate through Twitter's theme system
%hook T1ColorSettings

+ (void)_t1_applyPrimaryColorOption {
    %orig;
    
    // After Twitter applies its theme, ensure our custom tab bar styling is applied
    if ([BHTManager classicTabBarEnabled]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            BHT_UpdateAllTabBarIcons();
        });
    }
}

%end

%hook NSUserDefaults
- (void)setObject:(id)value forKey:(NSString *)defaultName {
    // Protect our theme color key from external changes
    if ([defaultName isEqualToString:@"T1ColorSettingsPrimaryColorOptionKey"]) {
        id selectedColor = [[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"];
        if (selectedColor != nil) {
            // Only allow setting to our chosen value
            if ([value isEqual:selectedColor]) {
                return %orig;
            } else {
                // Silently prevent changes to this key from outside
                return;
            }
        }
    }
    return %orig;
}
%end

// Improved BHT_ensureTheming to be more targeted and efficient
static void BHT_ensureTheming(void) {
    if (![[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) return;
    
    // Get the selected color option
    NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
    
    // Update our internal color state
    BH_changeTwitterColor(selectedOption);
    
    // Apply to Twitter's theme system
    id taeSettings = [objc_getClass("TAEColorSettings") sharedSettings];
    if ([taeSettings respondsToSelector:@selector(setPrimaryColorOption:)]) {
        [taeSettings setPrimaryColorOption:selectedOption];
    }
    
    // Notify Twitter's color system
    if ([objc_getClass("T1ColorSettings") respondsToSelector:@selector(_t1_applyPrimaryColorOption)]) {
        [objc_getClass("T1ColorSettings") _t1_applyPrimaryColorOption];
    }
    
    // Update UI elements that need specific handling
    dispatch_async(dispatch_get_main_queue(), ^{
        // Update all windows - tab bar icons need special handling
        BHT_UpdateAllTabBarIcons();
        
        // Refresh navigation bar icons
        for (UIWindow *window in [UIApplication sharedApplication].windows) {
            if (!window.isHidden && window.rootViewController) {
                BH_EnumerateSubviewsRecursively(window, ^(UIView *view) {
                    if ([view isKindOfClass:[objc_getClass("TFNNavigationBar") class]]) {
                        [(TFNNavigationBar *)view updateLogoTheme];
                    }
                });
            }
        }
    });
}

// Simplified window appearance refresh - focus on what matters
static void BHT_forceRefreshAllWindowAppearances(void) {
    // Update tab bar icons first - this is key for visual consistency
    BHT_UpdateAllTabBarIcons();
    
    for (UIWindow *window in [UIApplication sharedApplication].windows) {
        if (!window.isOpaque || window.isHidden) continue;
        
        // Focus on just the key elements that need updating
        if (window.rootViewController && window.rootViewController.isViewLoaded) {
            // Find and update navigation bars
            BH_EnumerateSubviewsRecursively(window.rootViewController.view, ^(UIView *view) {
                if ([view isKindOfClass:[objc_getClass("TFNNavigationBar") class]]) {
                    [(TFNNavigationBar *)view updateLogoTheme];
                }
            });
            
            // Force window layout refresh 
            [window.rootViewController.view setNeedsLayout];
            [window.rootViewController.view layoutIfNeeded];
        }
    }
}

// MARK: - Timestamp Label Styling via UILabel -setText:

// Global reference to the timestamp label for the active immersive player
static UILabel *gVideoTimestampLabel = nil;

// Helper method to determine if a text is likely a timestamp
static BOOL isTimestampText(NSString *text) {
    if (!text || text.length == 0) {
        return NO;
    }
    
    // Check for common timestamp patterns like "0:01/0:05" or "00:20/01:30"
    NSRange colonRange = [text rangeOfString:@":"];
    NSRange slashRange = [text rangeOfString:@"/"];
    
    // Must have both colon and slash
    if (colonRange.location == NSNotFound || slashRange.location == NSNotFound) {
        return NO;
    }
    
    // Slash should come after colon in a timestamp (e.g., "0:01/0:05")
    if (slashRange.location < colonRange.location) {
        return NO;
    }
    
    // Should have another colon after the slash
    NSRange secondColonRange = [text rangeOfString:@":" options:0 range:NSMakeRange(slashRange.location, text.length - slashRange.location)];
    if (secondColonRange.location == NSNotFound) {
        return NO;
    }
    
    return YES;
}

// Helper to find player controls in view hierarchy
static UIView *findPlayerControlsInHierarchy(UIView *startView) {
    if (!startView) return nil;
    
    __block UIView *playerControls = nil;
    BH_EnumerateSubviewsRecursively(startView, ^(UIView *view) {
        if (playerControls) return;
        
        NSString *className = NSStringFromClass([view class]);
        if ([className containsString:@"PlayerControlsView"] || 
            [className containsString:@"VideoControls"]) {
            playerControls = view;
        }
    });
    
    return playerControls;
}

%hook UILabel

- (void)setText:(NSString *)text {
    %orig(text);
    
    // Skip processing if feature is disabled
    if (![BHTManager restoreVideoTimestamp]) {
        return;
    }
    
    // Skip if already our target label
    if (self == gVideoTimestampLabel) {
        return;
    }
    
    // Skip if text doesn't match timestamp pattern
    if (!isTimestampText(self.text)) {
        return;
    }
    
    // Check if already styled
    if ([objc_getAssociatedObject(self, "BHT_StyledTimestamp") boolValue]) {
        return;
    }
    
    // Find if we're in the correct view context
    UIView *parentView = self.superview;
    BOOL isInImmersiveContext = NO;
    
    while (parentView) {
        NSString *className = NSStringFromClass([parentView class]);
        if ([className isEqualToString:@"T1TwitterSwift.ImmersiveCardView"] || 
            [className hasSuffix:@".ImmersiveCardView"]) {
            isInImmersiveContext = YES;
            break;
        }
        parentView = parentView.superview;
    }
    
    if (isInImmersiveContext) {
        NSLog(@"[BHTwitter Timestamp] Styling timestamp label: %@", self.text);
        
        // Apply styling - ONLY styling, not visibility
        self.font = [UIFont systemFontOfSize:14.0];
        self.textColor = [UIColor whiteColor];
        self.textAlignment = NSTextAlignmentCenter;
        self.backgroundColor = [UIColor colorWithWhite:0.0 alpha:0.5];
        
        // Calculate size and apply padding
        [self sizeToFit];
        CGRect frame = self.frame;
        CGFloat horizontalPadding = 4.0;
        CGFloat verticalPadding = 12.0;
        
        frame = CGRectMake(
            frame.origin.x - horizontalPadding / 2.0f,
            frame.origin.y - verticalPadding / 2.0f,
            frame.size.width + horizontalPadding,
            frame.size.height + verticalPadding
        );
        
        // Ensure minimum height
        if (frame.size.height < 22.0f) {
            CGFloat diff = 22.0f - frame.size.height;
            frame.size.height = 22.0f;
            frame.origin.y -= diff / 2.0f;
        }
        
        self.frame = frame;
        self.layer.cornerRadius = frame.size.height / 2.0f;
        self.layer.masksToBounds = YES;
        
        // Mark as styled and store reference
        objc_setAssociatedObject(self, "BHT_StyledTimestamp", @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        gVideoTimestampLabel = self;
    }
}

// For first-load mode, prevent hiding the timestamp
- (void)setHidden:(BOOL)hidden {
    // Only check labels that might be our timestamp
    if (self == gVideoTimestampLabel && [BHTManager restoreVideoTimestamp]) {
        // If trying to hide a fixed label, prevent it
        if (hidden) {
            BOOL isFixedForFirstLoad = [objc_getAssociatedObject(self, "BHT_FixedForFirstLoad") boolValue];
            if (isFixedForFirstLoad) {
                // Let the original method run but with "NO" instead of "YES"
                return %orig(NO);
            }
        }
    }
    
    // Default behavior
    %orig(hidden);
}

// Also prevent changing alpha to 0 for first-load labels
- (void)setAlpha:(CGFloat)alpha {
    // Only check our timestamp label
    if (self == gVideoTimestampLabel && [BHTManager restoreVideoTimestamp]) {
        // If trying to make a fixed label transparent, prevent it
        if (alpha == 0.0) {
            BOOL isFixedForFirstLoad = [objc_getAssociatedObject(self, "BHT_FixedForFirstLoad") boolValue];
            if (isFixedForFirstLoad) {
                // Keep it fully opaque during protected period
                return %orig(1.0);
            }
        }
    }
    
    // Default behavior
    %orig(alpha);
}

%end

// MARK: - Square Avatars (TFNAvatarImageView)

@interface TFNAvatarImageView : UIView // Assuming it's a UIView subclass, adjust if necessary
- (void)setStyle:(NSInteger)style;
- (NSInteger)style;
@end

%hook TFNAvatarImageView

- (void)setStyle:(NSInteger)style {
    if ([BHTManager squareAvatars]) {
        CGFloat activeCornerRadius;
        NSString *selfClassName = NSStringFromClass([self class]); // Get class name as string

        BOOL isDashAvatar = [selfClassName isEqualToString:@"TwitterDash.DashAvatarImageView"];
        BOOL isDashDrawerAvatar = [selfClassName isEqualToString:@"TwitterDash.DashDrawerAvatarImageView"];
        
        BOOL inDashHostingContext = isViewInsideDashHostingController(self);

        if (isDashDrawerAvatar) {
            // DashDrawerAvatarImageView always gets 8.0f regardless of context
            activeCornerRadius = 8.0f;
        } else if (isDashAvatar && inDashHostingContext) {
            // Regular DashAvatarImageView in hosting context gets 8.0f
            activeCornerRadius = 8.0f;
        } else if (isViewInsideT1ProfileHeaderViewController(self)) {
            // Avatars in profile header get 8.0f
            activeCornerRadius = 8.0f;
        } else {
            // Default for all other avatars is 12.0f
            activeCornerRadius = 12.0f;
        }

        %orig(3); // Call original with forced style 3

        // Force slightly rounded square on the main TFNAvatarImageView layer
        self.layer.cornerRadius = activeCornerRadius; 
        self.layer.masksToBounds = YES; // Ensure the main view clips

        // Find TIPImageViewObserver and force it to be slightly rounded
        for (NSUInteger i = 0; i < self.subviews.count; i++) {
            UIView *subview = [self.subviews objectAtIndex:i];
            NSString *subviewClassString = NSStringFromClass([subview class]);
            if ([subviewClassString isEqualToString:@"TIPImageViewObserver"]) {
                subview.layer.cornerRadius = activeCornerRadius;
                subview.layer.mask = nil;
                subview.clipsToBounds = YES;        // View property
                subview.layer.masksToBounds = YES;  // Layer property
                subview.contentMode = UIViewContentModeScaleAspectFill; // Set contentMode

                // Check for subviews of TIPImageViewObserver
                if (subview.subviews.count > 0) {
                    for (NSUInteger j = 0; j < subview.subviews.count; j++) {
                        UIView *tipSubview = [subview.subviews objectAtIndex:j];
                        tipSubview.layer.cornerRadius = activeCornerRadius;
                        tipSubview.layer.mask = nil;
                        tipSubview.clipsToBounds = YES;
                        tipSubview.layer.masksToBounds = YES;
                        tipSubview.contentMode = UIViewContentModeScaleAspectFill; // Set contentMode
                    }
                }
                break; // Assuming only one TIPImageViewObserver, exit loop
            }
        }
    } else {
        %orig;
    }
}

- (NSInteger)style {
    if ([BHTManager squareAvatars]) {
        return 3;
    }
    return %orig;
}

%end

// --- UIImage Hook Implementation ---
%hook UIImage

// Hook the specific TFN rounding method
- (UIImage *)tfn_roundImageWithTargetDimensions:(CGSize)targetDimensions targetContentMode:(UIViewContentMode)targetContentMode {
    if ([BHTManager squareAvatars]) {
        if (targetDimensions.width <= 0 || targetDimensions.height <= 0) {
            return self; // Avoid issues with zero/negative size
        }

        CGFloat cornerRadius = 12.0f;
        CGRect imageRect = CGRectMake(0, 0, targetDimensions.width, targetDimensions.height);

        // Ensure cornerRadius is not too large for the dimensions
        CGFloat minSide = MIN(targetDimensions.width, targetDimensions.height);
        if (cornerRadius > minSide / 2.0f) {
            cornerRadius = minSide / 2.0f; // Cap radius to avoid weird shapes
        }
        
        UIGraphicsBeginImageContextWithOptions(targetDimensions, NO, self.scale); // Use self.scale for retina, NO for opaque if image has alpha
        if (!UIGraphicsGetCurrentContext()) {
            UIGraphicsEndImageContext(); // Defensive call
            return self;
        }
        
        [[UIBezierPath bezierPathWithRoundedRect:imageRect cornerRadius:cornerRadius] addClip];
        [self drawInRect:imageRect];
        
        UIImage *roundedImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        
        if (roundedImage) {
            return roundedImage;
        } else {
            return self; // Fallback to original image if rounding fails
        }
    } else {
        return %orig;
    }
}

%end

// --- TFNCircularAvatarShadowLayer Hook Implementation ---
%hook TFNCircularAvatarShadowLayer

- (void)setHidden:(BOOL)hidden {
    if ([BHTManager squareAvatars]) {
        %orig(YES); // Always hide this layer when square avatars are enabled
    } else {
        %orig;
    }
}

%end


// MARK: - Combined constructor to initialize all hooks and features
%ctor {
    NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
    NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];
    // Someone needs to hold reference the to Notification
    _PasteboardChangeObserver = [center addObserverForName:UIPasteboardChangedNotification object:nil queue:mainQueue usingBlock:^(NSNotification * _Nonnull note){
        
        static dispatch_once_t onceToken;
        dispatch_once(&onceToken, ^{
            trackingParams = @{
                @"twitter.com" : @[@"s", @"t"],
                @"x.com" : @[@"s", @"t"],
            };
        });
        
        if ([BHTManager stripTrackingParams]) {
            if (UIPasteboard.generalPasteboard.hasURLs) {
                NSURL *pasteboardURL = UIPasteboard.generalPasteboard.URL;
                NSArray<NSString*>* params = trackingParams[pasteboardURL.host];
                
                if ([pasteboardURL.absoluteString isEqualToString:_lastCopiedURL] == NO && params != nil && pasteboardURL.query != nil) {
                    // to prevent endless copy loop
                    _lastCopiedURL = pasteboardURL.absoluteString;
                    NSURLComponents *cleanedURL = [NSURLComponents componentsWithURL:pasteboardURL resolvingAgainstBaseURL:NO];
                    NSMutableArray<NSURLQueryItem*> *safeParams = [NSMutableArray arrayWithCapacity:0];
                    
                    for (NSURLQueryItem *item in cleanedURL.queryItems) {
                        if ([params containsObject:item.name] == NO) {
                            [safeParams addObject:item];
                        }
                    }
                    cleanedURL.queryItems = safeParams.count > 0 ? safeParams : nil;

                    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"tweet_url_host"]) {
                        NSString *selectedHost = [[NSUserDefaults standardUserDefaults] objectForKey:@"tweet_url_host"];
                        cleanedURL.host = selectedHost;
                    }
                    UIPasteboard.generalPasteboard.URL = cleanedURL.URL;
                }
            }
        }
    }];
    
    // Initialize global Class pointers here when the tweak loads
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        gGuideContainerVCClass = NSClassFromString(@"T1TwitterSwift.GuideContainerViewController");
        if (!gGuideContainerVCClass) gGuideContainerVCClass = NSClassFromString(@"T1TwitterSwift_GuideContainerViewController");

        gTombstoneCellClass = NSClassFromString(@"T1TwitterSwift.ConversationTombstoneCell");
        if (!gTombstoneCellClass) gTombstoneCellClass = NSClassFromString(@"T1TwitterSwift_ConversationTombstoneCell");

        gExploreHeroCellClass = NSClassFromString(@"T1ExploreEventSummaryHeroTableViewCell");
        
        // Initialize T1ProfileHeaderViewController class pointer
        gT1ProfileHeaderViewControllerClass = NSClassFromString(@"T1ProfileHeaderViewController");
        
        // Initialize Dash specific class pointers
        gDashAvatarImageViewClass = NSClassFromString(@"TwitterDash.DashAvatarImageView");
        gDashDrawerAvatarImageViewClass = NSClassFromString(@"TwitterDash.DashDrawerAvatarImageView");
        
        // The full name for the hosting controller is very long and specific.
        gDashHostingControllerClass = NSClassFromString(@"_TtGC7SwiftUI19UIHostingControllerGV10TFNUISwift22HostingEnvironmentViewV11TwitterDash18DashNavigationView__");
    });
    
    // Initialize dictionaries for Tweet Source Labels restoration
    if (!tweetSources)      tweetSources      = [NSMutableDictionary dictionary];
    if (!viewToTweetID)     viewToTweetID     = [NSMutableDictionary dictionary];
    if (!fetchTimeouts)     fetchTimeouts     = [NSMutableDictionary dictionary];
    if (!viewInstances)     viewInstances     = [NSMutableDictionary dictionary];
    if (!fetchRetries)      fetchRetries      = [NSMutableDictionary dictionary];
    if (!updateRetries)     updateRetries     = [NSMutableDictionary dictionary];
    if (!updateCompleted)   updateCompleted   = [NSMutableDictionary dictionary];
    if (!fetchPending)      fetchPending      = [NSMutableDictionary dictionary];
    if (!cookieCache)       cookieCache       = [NSMutableDictionary dictionary];
    
    // Load cached cookies at initialization
    [TweetSourceHelper loadCachedCookies];
    
    %init;
    // REMOVED: Observer for BHTClassicTabBarSettingChanged (and its new equivalent CLASSIC_TAB_BAR_DISABLED_NOTIFICATION_NAME)
    // The logic for handling classic tab bar changes is now fully managed by restart.
    
    // Add observers for both window and theme changes
    [[NSNotificationCenter defaultCenter] addObserverForName:UIWindowDidBecomeVisibleNotification 
                                                    object:nil 
                                                     queue:[NSOperationQueue mainQueue] 
                                                usingBlock:^(NSNotification * _Nonnull note) {
        UIWindow *window = note.object;
        if (window && [[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
            BHT_applyThemeToWindow(window);
        }
    }];
    
    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidBecomeActiveNotification
                                                    object:nil 
                                                     queue:[NSOperationQueue mainQueue] 
                                                usingBlock:^(NSNotification * _Nonnull note) {
        BHT_ensureTheming();
    }];
    
    // Observe theme changes
    // REMOVED: Observer for BHTTabBarThemingChanged (second instance)
    // [[NSNotificationCenter defaultCenter] addObserverForName:@\"BHTTabBarThemingChanged\" 
    //                                                 object:nil 
    //                                                  queue:[NSOperationQueue mainQueue] 
    //                                             usingBlock:^(NSNotification * _Nonnull note) {
    //     BHT_ensureTheming(); // This was likely too broad, direct update is better.
    // }];

    static dispatch_once_t onceTokenPlayerMap;
    dispatch_once(&onceTokenPlayerMap, ^{
        playerToTimestampMap = [NSMapTable weakToStrongObjectsMapTable];
    });
}

// MARK: - DM Avatar Images
%hook T1DirectMessageEntryViewModel
- (BOOL)shouldShowAvatarImage {
    if (![BHTManager dmAvatars]) {
        return %orig;
    }
    
    if (self.isOutgoingMessage) {
        return NO; // Don't show avatar for your own messages
    }
    // For incoming messages, only show avatar if it's the last message in a group from that sender
    return [[self valueForKey:@"lastEntryInGroup"] boolValue];
}

- (BOOL)isAvatarImageEnabled {
    if (![BHTManager dmAvatars]) {
        return %orig;
    }
    
    // Always return YES so that space is allocated for the avatar,
    // allowing shouldShowAvatarImage to control actual visibility.
    return YES;
}
%end

// MARK: - Tab Bar Icon Theming
%hook T1TabView

%new
- (void)bh_applyCurrentThemeToIcon {
    UIImageView *imgView = nil;
    @try {
        imgView = [self valueForKey:@"imageView"];
    } @catch (NSException *exception) {
        NSLog(@"[BHTwitter TabTheme] Exception getting imageView: %@", exception);
        return;
    }
    if (!imgView) {
        NSLog(@"[BHTwitter TabTheme] imageView is nil.");
        return;
    }

    // MODIFIED: Logic for enabling/disabling theme
    if (![BHTManager classicTabBarEnabled]) {
        // Revert to default appearance
        imgView.tintColor = nil; 
        if (imgView.image) {
            // Attempt to set to a mode that respects original colors, or automatic.
            // UIImageRenderingModeAutomatic might be best if original isn't template.
            // If Twitter's default icons are always template, this might not show them correctly
            // without knowing their default non-themed tint color.
            // For now, assume nil tintColor and automatic rendering mode is the goal.
            imgView.image = [imgView.image imageWithRenderingMode:UIImageRenderingModeAutomatic];
        }
    } else {
        // Apply custom theme (existing logic)
        UIColor *targetColor;
        if ([[self valueForKey:@"selected"] boolValue]) { 
            targetColor = BHTCurrentAccentColor();
        } else {
            targetColor = [UIColor grayColor]; // Unselected but themed icon
        }
        
    if (imgView.image && imgView.image.renderingMode != UIImageRenderingModeAlwaysTemplate) {
        imgView.image = [imgView.image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
    }
        
    SEL applyTintColorSelector = @selector(applyTintColor:);
    if ([self respondsToSelector:applyTintColorSelector]) {
            ((void (*)(id, SEL, UIColor *))objc_msgSend)(self, applyTintColorSelector, targetColor);
    } else {
        imgView.tintColor = targetColor;
    }
    }

    // Always call Twitter's internal update method to refresh the visual state
    SEL updateImageViewSelector = NSSelectorFromString(@"_t1_updateImageViewAnimated:");
    if ([self respondsToSelector:updateImageViewSelector]) {
        IMP imp = [self methodForSelector:updateImageViewSelector];
        void (*func)(id, SEL, _Bool) = (void *)imp;
        func(self, updateImageViewSelector, NO); // Animate NO for immediate change
    } else if (imgView) {
        [imgView setNeedsDisplay]; // Fallback if the specific update method isn't found
    }
}

- (void)setSelected:(_Bool)selected {
    %orig(selected);
    [self performSelector:@selector(bh_applyCurrentThemeToIcon)];
}

// Optional: Hook _t1_updateImageViewAnimated if setSelected is not enough
// or if other state changes (like theme color change) need to trigger this.
/*
- (void)_t1_updateImageViewAnimated:(_Bool)animated {
    %orig(animated);
    [self bh_applyCurrentThemeToIcon]; 
}
*/

%end

%hook T1TabBarViewController

// + (void)load { // REMOVED
    // Initialize the hash table once
    // static dispatch_once_t onceToken;
    // dispatch_once(&onceToken, ^{
        // gTabBarControllers = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];
        // [[NSNotificationCenter defaultCenter] addObserverForName:NSUserDefaultsDidChangeNotification 
                                                          // object:nil 
                                                           // queue:[NSOperationQueue mainQueue] 
                                                      // usingBlock:^(NSNotification * _Nonnull note) {
            // BHTTabBarAccentColorChanged(NULL, NULL, NULL, NULL, NULL); 
        // }];
    // });
// }

- (void)viewDidLoad {
    %orig;
    // if (gTabBarControllers) { // REMOVED
        // [gTabBarControllers addObject:self]; // REMOVED
    // }
    // Apply theme on initial load
    if ([self respondsToSelector:@selector(tabViews)]) {
        NSArray *tabViews = [self valueForKey:@"tabViews"];
        for (id tabView in tabViews) {
            if ([tabView respondsToSelector:@selector(bh_applyCurrentThemeToIcon)]) {
                [tabView performSelector:@selector(bh_applyCurrentThemeToIcon)];
            }
        }
    }
}

- (void)dealloc {
    // if (gTabBarControllers) { // REMOVED
        // [gTabBarControllers removeObject:self]; // REMOVED
    // }
    %orig;
}

%end

// Helper: Update all tab bar icons
static void BHT_UpdateAllTabBarIcons(void) {
    // Iterate all windows and view controllers to find T1TabBarViewController
    for (UIWindow *window in UIApplication.sharedApplication.windows) {
        UIViewController *root = window.rootViewController;
        if (!root) continue;
        NSMutableArray *stack = [NSMutableArray arrayWithObject:root];
        while (stack.count > 0) {
            UIViewController *vc = [stack lastObject];
            [stack removeLastObject];
            if ([vc isKindOfClass:NSClassFromString(@"T1TabBarViewController")]) {
                NSArray *tabViews = [vc valueForKey:@"tabViews"];
                for (id tabView in tabViews) {
                    if ([tabView respondsToSelector:@selector(bh_applyCurrentThemeToIcon)]) {
                        [tabView performSelector:@selector(bh_applyCurrentThemeToIcon)];
                    }
                }
            }
            // Add children
            for (UIViewController *child in vc.childViewControllers) {
                [stack addObject:child];
            }
            if (vc.presentedViewController) {
                [stack addObject:vc.presentedViewController];
            }
        }
    }
}

static void BHT_applyThemeToWindow(UIWindow *window) {
    if (!window) return;

    // 1. Update our custom themed elements first
    // Update our custom tab bar icons
    if ([window.rootViewController isKindOfClass:NSClassFromString(@"T1TabBarViewController")]) {
        // Ensure BHT_UpdateAllTabBarIcons properly targets the tabViews of this specific window's rootVC
        // If BHT_UpdateAllTabBarIcons iterates all T1TabBarViewControllers globally, this direct call might be okay,
        // but targeting is safer if possible.
        BHT_UpdateAllTabBarIcons(); 
    }

    // Update our custom nav bar bird icon by recursively finding TFNNavigationBars
    BH_EnumerateSubviewsRecursively(window.rootViewController.view, ^(UIView *currentView) {
        if ([currentView isKindOfClass:NSClassFromString(@"TFNNavigationBar")]) {
            // updateLogoTheme should internally use BHTCurrentAccentColor()
            [(TFNNavigationBar *)currentView updateLogoTheme];
        }
    });

    // 2. Force a refresh of the currently visible content view hierarchy.
    // This is an attempt to make Twitter's own views re-evaluate the (now changed) accent color.
    UIViewController *rootVC = window.rootViewController;
    if (rootVC) {
        UIViewController *currentContentVC = rootVC;
        // Traverse to the most relevant visible content view controller
        if ([rootVC isKindOfClass:NSClassFromString(@"T1TabBarViewController")]) {
            // T1TabBarViewController is a UITabBarController subclass.
            // Cast to UITabBarController to access standard 'selectedViewController' property.
            if ([rootVC isKindOfClass:[UITabBarController class]]) {
                currentContentVC = ((UITabBarController *)rootVC).selectedViewController;
            }
        }
        
        // If the selected VC in a tab bar is a Nav controller, go to its visible VC
        if ([currentContentVC isKindOfClass:[UINavigationController class]]) {
            currentContentVC = [(UINavigationController *)currentContentVC visibleViewController];
        }

        // If we have a valid, loaded content view, tell it to redraw and re-layout.
        if (currentContentVC && currentContentVC.isViewLoaded) {
            [currentContentVC.view setNeedsDisplay];
            [currentContentVC.view setNeedsLayout];
            // Optionally, for a more immediate effect, though it can be costly if overused:
            // [currentContentVC.view layoutIfNeeded]; 
        }
    }
}

static void BHT_ensureTheming(void) {
    if (![[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) return;
    
    // Get the selected color option
    NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
    
    // Update our internal color state
    BH_changeTwitterColor(selectedOption);
    
    // Apply to Twitter's theme system
    id taeSettings = [objc_getClass("TAEColorSettings") sharedSettings];
    if ([taeSettings respondsToSelector:@selector(setPrimaryColorOption:)]) {
        [taeSettings setPrimaryColorOption:selectedOption];
    }
    
    // Notify Twitter's color system
    if ([objc_getClass("T1ColorSettings") respondsToSelector:@selector(_t1_applyPrimaryColorOption)]) {
        [objc_getClass("T1ColorSettings") _t1_applyPrimaryColorOption];
    }
    
    // Update UI elements that need specific handling
    dispatch_async(dispatch_get_main_queue(), ^{
        // Update all windows - tab bar icons need special handling
        BHT_UpdateAllTabBarIcons();
        
        // Refresh navigation bar icons
        for (UIWindow *window in [UIApplication sharedApplication].windows) {
            if (!window.isHidden && window.rootViewController) {
                BH_EnumerateSubviewsRecursively(window, ^(UIView *view) {
                    if ([view isKindOfClass:[objc_getClass("TFNNavigationBar") class]]) {
                        [(TFNNavigationBar *)view updateLogoTheme];
                    }
                });
            }
        }
    });
}

static void BHT_forceRefreshAllWindowAppearances(void) { // Renamed and logic adjusted
    // 1. Update our custom elements (these seem to work reliably)
    BHT_UpdateAllTabBarIcons(); 
    
    for (UIWindow *window in [UIApplication sharedApplication].windows) {
        if (!window.isOpaque || window.isHidden) continue; // Skip non-visible or transparent windows

        // Update our custom nav bar bird icon for this window
        if (window.rootViewController && window.rootViewController.isViewLoaded) {
            BH_EnumerateSubviewsRecursively(window.rootViewController.view, ^(UIView *currentView) {
                if ([currentView isKindOfClass:NSClassFromString(@"TFNNavigationBar")]) {
                    if ([BHTManager classicTabBarEnabled]) { // MODIFIED: Used classicTabBarEnabled
                        [(TFNNavigationBar *)currentView updateLogoTheme];
                    }
                }
            });
        }

        // Attempt to "jolt" this window's hierarchy
        UIViewController *rootVC = window.rootViewController;
        if (rootVC && rootVC.isViewLoaded) {
            BH_EnumerateSubviewsRecursively(rootVC.view, ^(UIView *subview) {
                if ([subview respondsToSelector:@selector(tintColorDidChange)]) {
                    [subview tintColorDidChange];
                }
                if ([subview respondsToSelector:@selector(setNeedsDisplay)]) {
                    [subview setNeedsDisplay]; // Force redraw
                }
            });
            [rootVC.view setNeedsLayout];
            [rootVC.view layoutIfNeeded];
            [rootVC.view setNeedsDisplay]; // Redraw the whole root view of the window
        }
    }
}

// MARK: Theme TFNBarButtonItemButtonV2
%hook TFNBarButtonItemButtonV2
- (void)didMoveToWindow {
    %orig;
    if (self.window) {
        self.tintColor = BHTCurrentAccentColor();
    }
}

- (void)setTintColor:(UIColor *)tintColor {
    %orig(BHTCurrentAccentColor());
}
%end

// MARK: - Timestamp Label Styling via UILabel -setText:

// MARK: - Immersive Player Timestamp Visibility Control

%hook T1ImmersiveFullScreenViewController

// Forward declare the new helper method for visibility within this hook block
- (BOOL)BHT_findAndPrepareTimestampLabelForVC:(T1ImmersiveFullScreenViewController *)activePlayerVC;

// Helper method to find, style, and map the timestamp label for a given VC instance
%new - (BOOL)BHT_findAndPrepareTimestampLabelForVC:(T1ImmersiveFullScreenViewController *)activePlayerVC {
    // ... (implementation as before)
    if (!playerToTimestampMap || !activePlayerVC || !activePlayerVC.isViewLoaded) {
        NSLog(@"[BHTwitter Timestamp] BHT_findAndPrepareTimestampLabelForVC: Pre-condition failed (map: %@, vc: %@, viewLoaded: %d)", playerToTimestampMap, activePlayerVC, activePlayerVC.isViewLoaded);
        return NO;
    }

    UILabel *timestampLabel = [playerToTimestampMap objectForKey:activePlayerVC];

    BOOL needsFreshFind = (!timestampLabel || !timestampLabel.superview || ![timestampLabel.superview isDescendantOfView:activePlayerVC.view]);
    if (timestampLabel && timestampLabel.superview && 
        (![timestampLabel.text containsString:@":"] || ![timestampLabel.text containsString:@"/"])) {
        needsFreshFind = YES;
        NSLog(@"[BHTwitter Timestamp] VC %@: Label %@ found with non-timestamp text: \"%@\". Forcing re-find.", activePlayerVC, timestampLabel, timestampLabel.text);
        [playerToTimestampMap removeObjectForKey:activePlayerVC];
        timestampLabel = nil;
    }
    
    if (needsFreshFind) {
        NSLog(@"[BHTwitter Timestamp] VC %@: Needs fresh find for label.", activePlayerVC);
        __block UILabel *foundCandidate = nil;
        UIView *searchView = activePlayerVC.view;

        BH_EnumerateSubviewsRecursively(searchView, ^(UIView *currentView) {
            if (foundCandidate) return;
            if ([currentView isKindOfClass:[UILabel class]]) {
                UILabel *label = (UILabel *)currentView;
                UIView *v = label.superview;
                BOOL inImmersiveCardViewContext = NO;
                while(v && v != searchView.window && v != searchView) {
                    NSString *className = NSStringFromClass([v class]);
                    if ([className isEqualToString:@"T1TwitterSwift.ImmersiveCardView"] || [className hasSuffix:@".ImmersiveCardView"]) {
                        inImmersiveCardViewContext = YES;
                break;
            }
                    v = v.superview;
                }

                if (inImmersiveCardViewContext && label.text && [label.text containsString:@":"] && [label.text containsString:@"/"]) {
                    NSLog(@"[BHTwitter Timestamp] VC %@: Candidate label found: Text='%@', Superview=%@", activePlayerVC, label.text, NSStringFromClass(label.superview.class));
                    foundCandidate = label;
                }
            }
        });

        if (foundCandidate) {
            timestampLabel = foundCandidate;
            [playerToTimestampMap setObject:timestampLabel forKey:activePlayerVC];
            NSLog(@"[BHTwitter Timestamp] VC %@: Associated label %@ in map.", activePlayerVC, timestampLabel);
        } else {
            if ([playerToTimestampMap objectForKey:activePlayerVC]) {
                 NSLog(@"[BHTwitter Timestamp] VC %@: No label found, removing existing map entry.", activePlayerVC);
                [playerToTimestampMap removeObjectForKey:activePlayerVC];
            }
            return NO;
        }
    }

    if (timestampLabel && ![objc_getAssociatedObject(timestampLabel, "BHT_StyledTimestamp") boolValue]) {
        NSLog(@"[BHTwitter Timestamp] VC %@: Styling label %@.", activePlayerVC, timestampLabel);
        timestampLabel.font = [UIFont systemFontOfSize:14.0];
        timestampLabel.textColor = [UIColor whiteColor];
        timestampLabel.textAlignment = NSTextAlignmentCenter;
        timestampLabel.backgroundColor = [UIColor colorWithWhite:0.0 alpha:0.5];

        [timestampLabel sizeToFit];
        CGRect currentFrame = timestampLabel.frame;
        CGFloat horizontalPadding = 2.0; // Padding on EACH side
        CGFloat verticalPadding = 12.0; // TOTAL vertical padding (6.0 on each side)
        
        CGRect newFrame = CGRectMake(
            currentFrame.origin.x - horizontalPadding, 
            currentFrame.origin.y - (verticalPadding / 2.0f),
            currentFrame.size.width + (horizontalPadding * 2),
                currentFrame.size.height + verticalPadding
            );
            
        if (newFrame.size.height < 22.0f) {
            CGFloat heightDiff = 22.0f - newFrame.size.height;
            newFrame.size.height = 22.0f;
            newFrame.origin.y -= heightDiff / 2.0f;
        }
        timestampLabel.frame = newFrame;
        timestampLabel.layer.cornerRadius = newFrame.size.height / 2.0f;
        timestampLabel.layer.masksToBounds = YES;
        objc_setAssociatedObject(timestampLabel, "BHT_StyledTimestamp", @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
    return (timestampLabel != nil && timestampLabel.superview != nil); // Ensure it's also in a superview
}

- (void)immersiveViewController:(id)passedImmersiveViewController showHideNavigationButtons:(_Bool)showButtons {
    // Store the original value for "showButtons"
    BOOL originalShowButtons = showButtons;
    
    // Force buttons to be visible for first load
    BOOL isFirstLoad = ![objc_getAssociatedObject(self, "BHT_FirstLoadDone") boolValue];
    if (isFirstLoad && [BHTManager restoreVideoTimestamp]) {
        // For first load, FORCE buttons to be visible (override the incoming parameter)
        showButtons = YES;
        
        // Only allow normal hiding after a delay - set a timer in first call
        if (!objc_getAssociatedObject(self, "BHT_TimerStarted")) {
            objc_setAssociatedObject(self, "BHT_TimerStarted", @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
            
            // After a delay, allow normal behavior by marking first load as done
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.75 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                if (self && self.view.window) {
                    objc_setAssociatedObject(self, "BHT_FirstLoadDone", @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
                    NSLog(@"[BHTwitter Timestamp] Player can now hide controls normally");
                }
            });
        }
    }
    
    // Call original with possibly modified parameter
    %orig(passedImmersiveViewController, showButtons);
    
    T1ImmersiveFullScreenViewController *activePlayerVC = self;
    NSLog(@"[BHTwitter Timestamp] VC %@: showHideNavigationButtons: %d (original: %d)", activePlayerVC, showButtons, originalShowButtons);

    // The rest of the method remains unchanged
    if (![BHTManager restoreVideoTimestamp]) {
        if (playerToTimestampMap) {
            UILabel *labelToManage = [playerToTimestampMap objectForKey:activePlayerVC];
            if (labelToManage) {
                labelToManage.hidden = YES;
                NSLog(@"[BHTwitter Timestamp] VC %@: Hiding label (feature disabled).", activePlayerVC);
            }
        }
        return;
    }
    
    SEL findAndPrepareSelector = NSSelectorFromString(@"BHT_findAndPrepareTimestampLabelForVC:");
    BOOL labelReady = NO;

    if ([self respondsToSelector:findAndPrepareSelector]) {
        NSMethodSignature *signature = [self methodSignatureForSelector:findAndPrepareSelector];
        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
        [invocation setSelector:findAndPrepareSelector];
        [invocation setTarget:self];
        [invocation setArgument:&activePlayerVC atIndex:2]; // Arguments start at index 2 (0 = self, 1 = _cmd)
        [invocation invoke];
        [invocation getReturnValue:&labelReady];
    } else {
        NSLog(@"[BHTwitter Timestamp] VC %@: ERROR - Does not respond to selector BHT_findAndPrepareTimestampLabelForVC:", activePlayerVC);
    }

    if (labelReady) {
        UILabel *timestampLabel = [playerToTimestampMap objectForKey:activePlayerVC];
        if (timestampLabel) { 
            // For normal operation, let the player handle visibility and animations - it was already called in %orig
            if (showButtons) {
                NSLog(@"[BHTwitter Timestamp] VC %@: SHOWING label %@.", activePlayerVC, timestampLabel);
            } else {
                NSLog(@"[BHTwitter Timestamp] VC %@: HIDING label %@.", activePlayerVC, timestampLabel);
            }
        } else {
            NSLog(@"[BHTwitter Timestamp] VC %@: Label was ready but map returned nil.", activePlayerVC);
        }
    } else {
        NSLog(@"[BHTwitter Timestamp] VC %@: Label not ready after findAndPrepare.", activePlayerVC);
    }
}

- (void)viewDidAppear:(BOOL)animated {
    %orig(animated);
    T1ImmersiveFullScreenViewController *activePlayerVC = self;
    NSLog(@"[BHTwitter Timestamp] VC %@: viewDidAppear.", activePlayerVC);

    if ([BHTManager restoreVideoTimestamp]) {
        if (!playerToTimestampMap) { 
            playerToTimestampMap = [NSMapTable weakToStrongObjectsMapTable];
        }
        
        // Check if this is the first load for this controller
        BOOL isFirstLoad = ![objc_getAssociatedObject(activePlayerVC, "BHT_FirstLoadDone") boolValue];
        
        // Initial attempt to find the label
        BOOL labelFoundAndPrepared = [self BHT_findAndPrepareTimestampLabelForVC:activePlayerVC];
        
        if (isFirstLoad && labelFoundAndPrepared) {
            // Only for first load - ensure the timestamp is visible
            UILabel *timestampLabel = [playerToTimestampMap objectForKey:activePlayerVC];
            if (timestampLabel) {
                // Set the label as visible for first load - no animation
                // Let the player handle animation transitions
                timestampLabel.alpha = 1.0;
                timestampLabel.hidden = NO;
                
                // Mark it as fixed for first load to prevent early hiding
                objc_setAssociatedObject(timestampLabel, "BHT_FixedForFirstLoad", @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
                
                // After a delay, transition to normal player control
                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                    if (activePlayerVC && activePlayerVC.view.window && timestampLabel && timestampLabel.superview) {
                        // End first load mode and let player take over
                        objc_setAssociatedObject(activePlayerVC, "BHT_FirstLoadDone", @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
                        objc_setAssociatedObject(timestampLabel, "BHT_FixedForFirstLoad", @NO, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
                        
                        // Let the player decide visibility based on current controls state
                        BOOL controlsVisible = NO;
                        if ([activePlayerVC respondsToSelector:@selector(playerControlsView)]) { 
                            UIView *playerControls = [activePlayerVC valueForKey:@"playerControlsView"];
                            if (playerControls) {
                                controlsVisible = playerControls.alpha > 0.0f;
                            }
                        }
                        
                        // Use the player's native method to update UI elements
                        [activePlayerVC immersiveViewController:activePlayerVC showHideNavigationButtons:controlsVisible];
                    }
                });
            }
        } else {
            // For non-first loads, just let the player handle visibility as normal
            [self immersiveViewController:self showHideNavigationButtons:NO];
        }
    }
}

- (void)playerViewController:(id)playerViewController playerStateDidChange:(NSInteger)state {
    %orig(playerViewController, state);
    T1ImmersiveFullScreenViewController *activePlayerVC = self;
    NSLog(@"[BHTwitter Timestamp] VC %@: playerStateDidChange: %ld", activePlayerVC, (long)state);

    if (![BHTManager restoreVideoTimestamp] || !playerToTimestampMap) {
        NSLog(@"[BHTwitter Timestamp] VC %@: playerStateDidChange - Bailing early (feature off or map nil)", activePlayerVC);
        return;
    }

    // Always try to find/prepare the label for the current video content.
    // This is crucial if the VC is reused and new video content has loaded.
    BOOL labelFoundAndPrepared = [self BHT_findAndPrepareTimestampLabelForVC:activePlayerVC];
    NSLog(@"[BHTwitter Timestamp] VC %@: playerStateDidChange - labelFoundAndPrepared: %d", activePlayerVC, labelFoundAndPrepared);

    if (labelFoundAndPrepared) {
        UILabel *timestampLabel = [playerToTimestampMap objectForKey:activePlayerVC];
        if (timestampLabel && timestampLabel.superview && [timestampLabel isDescendantOfView:activePlayerVC.view]) {
            // Determine current intended visibility of controls.
            // This relies on the main showHideNavigationButtons method being the source of truth for user-initiated toggles.
            // Here, we primarily react to player state changes that might imply controls should appear/disappear.
            BOOL controlsShouldBeVisible = NO;
            UIView *playerControls = nil;
            if ([activePlayerVC respondsToSelector:@selector(playerControlsView)]) { 
                playerControls = [activePlayerVC valueForKey:@"playerControlsView"];
                if (playerControls && [playerControls respondsToSelector:@selector(alpha)]) {
                    controlsShouldBeVisible = playerControls.alpha > 0.0f;
                    NSLog(@"[BHTwitter Timestamp] VC %@: playerStateDidChange - current playerControls.alpha: %f", activePlayerVC, playerControls.alpha);
                }
            }

            // If player state implies controls *should* be visible (e.g., paused, ready and controls were already up),
            // ensure our timestamp is visible. The primary toggling is done by showHideNavigationButtons.
            // This is more about reacting to player-induced control visibility changes.
            // For example, if the video pauses and Twitter automatically shows controls.
            
            // More direct: Mirror the state set by showHideNavigationButtons, which should be the authority.
            // The key is that showHideNavigationButtons should have ALREADY run if controls became visible due to player state.
            // So, if our label is hidden but controls are visible, something is out of sync OR this state change *caused* controls to show.

            if (controlsShouldBeVisible) {
                if (timestampLabel.hidden) {
                    NSLog(@"[BHTwitter Timestamp] VC %@: playerStateDidChange - Controls ARE visible, label WAS hidden. SHOWING label %@.", activePlayerVC, timestampLabel);
                    timestampLabel.alpha = 1.0;
                    timestampLabel.hidden = NO;
                }
                } else {
                if (!timestampLabel.hidden) {
                    // Only hide if playerControls view exists and is actually not visible.
                    // Avoids hiding if playerControlsView is nil or alpha check is inconclusive.
                    if (playerControls && playerControls.alpha == 0.0f) { 
                        NSLog(@"[BHTwitter Timestamp] VC %@: playerStateDidChange - Controls ARE NOT visible (alpha 0), label WAS visible. HIDING label %@.", activePlayerVC, timestampLabel);
                        timestampLabel.hidden = YES;
                        timestampLabel.alpha = 0.0;
                    }
                }
            }
        } else {
            NSLog(@"[BHTwitter Timestamp] VC %@: playerStateDidChange - Label was prepared but map/superview check failed.", activePlayerVC);
        }
    } else {
        NSLog(@"[BHTwitter Timestamp] VC %@: playerStateDidChange - Label not found/prepared.", activePlayerVC);
    }
}

%end

// MARK: - Square Avatars (TFNAvatarImageView)

@interface TFNAvatarImageView : UIView // Assuming it's a UIView subclass, adjust if necessary
- (void)setStyle:(NSInteger)style;
- (NSInteger)style;
@end

%hook TFNAvatarImageView

- (void)setStyle:(NSInteger)style {
    if ([BHTManager squareAvatars]) {
        CGFloat activeCornerRadius;
        NSString *selfClassName = NSStringFromClass([self class]); // Get class name as string

        BOOL isDashAvatar = [selfClassName isEqualToString:@"TwitterDash.DashAvatarImageView"];
        BOOL isDashDrawerAvatar = [selfClassName isEqualToString:@"TwitterDash.DashDrawerAvatarImageView"];
        
        BOOL inDashHostingContext = isViewInsideDashHostingController(self);

        if (isDashDrawerAvatar) {
            // DashDrawerAvatarImageView always gets 8.0f regardless of context
            activeCornerRadius = 8.0f;
        } else if (isDashAvatar && inDashHostingContext) {
            // Regular DashAvatarImageView in hosting context gets 8.0f
            activeCornerRadius = 8.0f;
        } else if (isViewInsideT1ProfileHeaderViewController(self)) {
            // Avatars in profile header get 8.0f
            activeCornerRadius = 8.0f;
        } else {
            // Default for all other avatars is 12.0f
            activeCornerRadius = 12.0f;
        }

        %orig(3); // Call original with forced style 3

        // Force slightly rounded square on the main TFNAvatarImageView layer
        self.layer.cornerRadius = activeCornerRadius; 
        self.layer.masksToBounds = YES; // Ensure the main view clips

        // Find TIPImageViewObserver and force it to be slightly rounded
        for (NSUInteger i = 0; i < self.subviews.count; i++) {
            UIView *subview = [self.subviews objectAtIndex:i];
            NSString *subviewClassString = NSStringFromClass([subview class]);
            if ([subviewClassString isEqualToString:@"TIPImageViewObserver"]) {
                subview.layer.cornerRadius = activeCornerRadius;
                subview.layer.mask = nil;
                subview.clipsToBounds = YES;        // View property
                subview.layer.masksToBounds = YES;  // Layer property
                subview.contentMode = UIViewContentModeScaleAspectFill; // Set contentMode

                // Check for subviews of TIPImageViewObserver
                if (subview.subviews.count > 0) {
                    for (NSUInteger j = 0; j < subview.subviews.count; j++) {
                        UIView *tipSubview = [subview.subviews objectAtIndex:j];
                        tipSubview.layer.cornerRadius = activeCornerRadius;
                        tipSubview.layer.mask = nil;
                        tipSubview.clipsToBounds = YES;
                        tipSubview.layer.masksToBounds = YES;
                        tipSubview.contentMode = UIViewContentModeScaleAspectFill; // Set contentMode
                    }
                }
                break; // Assuming only one TIPImageViewObserver, exit loop
            }
        }
    } else {
        %orig;
    }
}

- (NSInteger)style {
    if ([BHTManager squareAvatars]) {
        return 3;
    }
    return %orig;
}

%end

// --- UIImage Hook Implementation ---
%hook UIImage

// Hook the specific TFN rounding method
- (UIImage *)tfn_roundImageWithTargetDimensions:(CGSize)targetDimensions targetContentMode:(UIViewContentMode)targetContentMode {
    if ([BHTManager squareAvatars]) {
        if (targetDimensions.width <= 0 || targetDimensions.height <= 0) {
            return self; // Avoid issues with zero/negative size
        }

        CGFloat cornerRadius = 12.0f;
        CGRect imageRect = CGRectMake(0, 0, targetDimensions.width, targetDimensions.height);

        // Ensure cornerRadius is not too large for the dimensions
        CGFloat minSide = MIN(targetDimensions.width, targetDimensions.height);
        if (cornerRadius > minSide / 2.0f) {
            cornerRadius = minSide / 2.0f; // Cap radius to avoid weird shapes
        }
        
        UIGraphicsBeginImageContextWithOptions(targetDimensions, NO, self.scale); // Use self.scale for retina, NO for opaque if image has alpha
        if (!UIGraphicsGetCurrentContext()) {
            UIGraphicsEndImageContext(); // Defensive call
            return self;
        }
        
        [[UIBezierPath bezierPathWithRoundedRect:imageRect cornerRadius:cornerRadius] addClip];
        [self drawInRect:imageRect];
        
        UIImage *roundedImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        
        if (roundedImage) {
            return roundedImage;
        } else {
            return self; // Fallback to original image if rounding fails
        }
    } else {
        return %orig;
    }
}

%end

// --- TFNCircularAvatarShadowLayer Hook Implementation ---
%hook TFNCircularAvatarShadowLayer

- (void)setHidden:(BOOL)hidden {
    if ([BHTManager squareAvatars]) {
        %orig(YES); // Always hide this layer when square avatars are enabled
    } else {
        %orig;
    }
}

%end


// MARK: - Combined constructor to initialize all hooks and features
%ctor {
    NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
    NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];
    // Someone needs to hold reference the to Notification
    _PasteboardChangeObserver = [center addObserverForName:UIPasteboardChangedNotification object:nil queue:mainQueue usingBlock:^(NSNotification * _Nonnull note){
        
        static dispatch_once_t onceToken;
        dispatch_once(&onceToken, ^{
            trackingParams = @{
                @"twitter.com" : @[@"s", @"t"],
                @"x.com" : @[@"s", @"t"],
            };
        });
        
        if ([BHTManager stripTrackingParams]) {
            if (UIPasteboard.generalPasteboard.hasURLs) {
                NSURL *pasteboardURL = UIPasteboard.generalPasteboard.URL;
                NSArray<NSString*>* params = trackingParams[pasteboardURL.host];
                
                if ([pasteboardURL.absoluteString isEqualToString:_lastCopiedURL] == NO && params != nil && pasteboardURL.query != nil) {
                    // to prevent endless copy loop
                    _lastCopiedURL = pasteboardURL.absoluteString;
                    NSURLComponents *cleanedURL = [NSURLComponents componentsWithURL:pasteboardURL resolvingAgainstBaseURL:NO];
                    NSMutableArray<NSURLQueryItem*> *safeParams = [NSMutableArray arrayWithCapacity:0];
                    
                    for (NSURLQueryItem *item in cleanedURL.queryItems) {
                        if ([params containsObject:item.name] == NO) {
                            [safeParams addObject:item];
                        }
                    }
                    cleanedURL.queryItems = safeParams.count > 0 ? safeParams : nil;

                    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"tweet_url_host"]) {
                        NSString *selectedHost = [[NSUserDefaults standardUserDefaults] objectForKey:@"tweet_url_host"];
                        cleanedURL.host = selectedHost;
                    }
                    UIPasteboard.generalPasteboard.URL = cleanedURL.URL;
                }
            }
        }
    }];
    
    // Initialize global Class pointers here when the tweak loads
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        gGuideContainerVCClass = NSClassFromString(@"T1TwitterSwift.GuideContainerViewController");
        if (!gGuideContainerVCClass) gGuideContainerVCClass = NSClassFromString(@"T1TwitterSwift_GuideContainerViewController");

        gTombstoneCellClass = NSClassFromString(@"T1TwitterSwift.ConversationTombstoneCell");
        if (!gTombstoneCellClass) gTombstoneCellClass = NSClassFromString(@"T1TwitterSwift_ConversationTombstoneCell");

        gExploreHeroCellClass = NSClassFromString(@"T1ExploreEventSummaryHeroTableViewCell");
        
        // Initialize T1ProfileHeaderViewController class pointer
        gT1ProfileHeaderViewControllerClass = NSClassFromString(@"T1ProfileHeaderViewController");
        
        // Initialize Dash specific class pointers
        gDashAvatarImageViewClass = NSClassFromString(@"TwitterDash.DashAvatarImageView");
        gDashDrawerAvatarImageViewClass = NSClassFromString(@"TwitterDash.DashDrawerAvatarImageView");
        
        // The full name for the hosting controller is very long and specific.
        gDashHostingControllerClass = NSClassFromString(@"_TtGC7SwiftUI19UIHostingControllerGV10TFNUISwift22HostingEnvironmentViewV11TwitterDash18DashNavigationView__");
    });
    
    // Initialize dictionaries for Tweet Source Labels restoration
    if (!tweetSources)      tweetSources      = [NSMutableDictionary dictionary];
    if (!viewToTweetID)     viewToTweetID     = [NSMutableDictionary dictionary];
    if (!fetchTimeouts)     fetchTimeouts     = [NSMutableDictionary dictionary];
    if (!viewInstances)     viewInstances     = [NSMutableDictionary dictionary];
    if (!fetchRetries)      fetchRetries      = [NSMutableDictionary dictionary];
    if (!updateRetries)     updateRetries     = [NSMutableDictionary dictionary];
    if (!updateCompleted)   updateCompleted   = [NSMutableDictionary dictionary];
    if (!fetchPending)      fetchPending      = [NSMutableDictionary dictionary];
    if (!cookieCache)       cookieCache       = [NSMutableDictionary dictionary];
    
    // Load cached cookies at initialization
    [TweetSourceHelper loadCachedCookies];
    
    %init;
    // REMOVED: Observer for BHTClassicTabBarSettingChanged (and its new equivalent CLASSIC_TAB_BAR_DISABLED_NOTIFICATION_NAME)
    // The logic for handling classic tab bar changes is now fully managed by restart.
    
    // Add observers for both window and theme changes
    [[NSNotificationCenter defaultCenter] addObserverForName:UIWindowDidBecomeVisibleNotification 
                                                    object:nil 
                                                     queue:[NSOperationQueue mainQueue] 
                                                usingBlock:^(NSNotification * _Nonnull note) {
        UIWindow *window = note.object;
        if (window && [[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
            BHT_applyThemeToWindow(window);
        }
    }];
    
    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidBecomeActiveNotification
                                                    object:nil 
                                                     queue:[NSOperationQueue mainQueue] 
                                                usingBlock:^(NSNotification * _Nonnull note) {
        BHT_ensureTheming();
    }];
    
    // Observe theme changes
    // REMOVED: Observer for BHTTabBarThemingChanged (second instance)
    // [[NSNotificationCenter defaultCenter] addObserverForName:@\"BHTTabBarThemingChanged\" 
    //                                                 object:nil 
    //                                                  queue:[NSOperationQueue mainQueue] 
    //                                             usingBlock:^(NSNotification * _Nonnull note) {
    //     BHT_ensureTheming(); // This was likely too broad, direct update is better.
    // }];

    static dispatch_once_t onceTokenPlayerMap;
    dispatch_once(&onceTokenPlayerMap, ^{
        playerToTimestampMap = [NSMapTable weakToStrongObjectsMapTable];
    });
}

// MARK: - DM Avatar Images
%hook T1DirectMessageEntryViewModel
- (BOOL)shouldShowAvatarImage {
    if (![BHTManager dmAvatars]) {
        return %orig;
    }
    
    if (self.isOutgoingMessage) {
        return NO; // Don't show avatar for your own messages
    }
    // For incoming messages, only show avatar if it's the last message in a group from that sender
    return [[self valueForKey:@"lastEntryInGroup"] boolValue];
}

- (BOOL)isAvatarImageEnabled {
    if (![BHTManager dmAvatars]) {
        return %orig;
    }
    
    // Always return YES so that space is allocated for the avatar,
    // allowing shouldShowAvatarImage to control actual visibility.
    return YES;
}
%end

// MARK: - Tab Bar Icon Theming
%hook T1TabView

%new
- (void)bh_applyCurrentThemeToIcon {
    UIImageView *imgView = nil;
    @try {
        imgView = [self valueForKey:@"imageView"];
    } @catch (NSException *exception) {
        NSLog(@"[BHTwitter TabTheme] Exception getting imageView: %@", exception);
        return;
    }
    if (!imgView) {
        NSLog(@"[BHTwitter TabTheme] imageView is nil.");
        return;
    }

    // MODIFIED: Logic for enabling/disabling theme
    if (![BHTManager classicTabBarEnabled]) {
        // Revert to default appearance
        imgView.tintColor = nil; 
        if (imgView.image) {
            // Attempt to set to a mode that respects original colors, or automatic.
            // UIImageRenderingModeAutomatic might be best if original isn't template.
            // If Twitter's default icons are always template, this might not show them correctly
            // without knowing their default non-themed tint color.
            // For now, assume nil tintColor and automatic rendering mode is the goal.
            imgView.image = [imgView.image imageWithRenderingMode:UIImageRenderingModeAutomatic];
        }
    } else {
        // Apply custom theme (existing logic)
        UIColor *targetColor;
        if ([[self valueForKey:@"selected"] boolValue]) { 
            targetColor = BHTCurrentAccentColor();
        } else {
            targetColor = [UIColor grayColor]; // Unselected but themed icon
        }
        
    if (imgView.image && imgView.image.renderingMode != UIImageRenderingModeAlwaysTemplate) {
        imgView.image = [imgView.image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
    }
        
    SEL applyTintColorSelector = @selector(applyTintColor:);
    if ([self respondsToSelector:applyTintColorSelector]) {
            ((void (*)(id, SEL, UIColor *))objc_msgSend)(self, applyTintColorSelector, targetColor);
    } else {
        imgView.tintColor = targetColor;
    }
    }

    // Always call Twitter's internal update method to refresh the visual state
    SEL updateImageViewSelector = NSSelectorFromString(@"_t1_updateImageViewAnimated:");
    if ([self respondsToSelector:updateImageViewSelector]) {
        IMP imp = [self methodForSelector:updateImageViewSelector];
        void (*func)(id, SEL, _Bool) = (void *)imp;
        func(self, updateImageViewSelector, NO); // Animate NO for immediate change
    } else if (imgView) {
        [imgView setNeedsDisplay]; // Fallback if the specific update method isn't found
    }
}

- (void)setSelected:(_Bool)selected {
    %orig(selected);
    [self performSelector:@selector(bh_applyCurrentThemeToIcon)];
}

// Optional: Hook _t1_updateImageViewAnimated if setSelected is not enough
// or if other state changes (like theme color change) need to trigger this.
/*
- (void)_t1_updateImageViewAnimated:(_Bool)animated {
    %orig(animated);
    [self bh_applyCurrentThemeToIcon]; 
}
*/

%end

%hook T1TabBarViewController

// + (void)load { // REMOVED
    // Initialize the hash table once
    // static dispatch_once_t onceToken;
    // dispatch_once(&onceToken, ^{
        // gTabBarControllers = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];
        // [[NSNotificationCenter defaultCenter] addObserverForName:NSUserDefaultsDidChangeNotification 
                                                          // object:nil 
                                                           // queue:[NSOperationQueue mainQueue] 
                                                      // usingBlock:^(NSNotification * _Nonnull note) {
            // BHTTabBarAccentColorChanged(NULL, NULL, NULL, NULL, NULL); 
        // }];
    // });
// }

- (void)viewDidLoad {
    %orig;
    // if (gTabBarControllers) { // REMOVED
        // [gTabBarControllers addObject:self]; // REMOVED
    // }
    // Apply theme on initial load
    if ([self respondsToSelector:@selector(tabViews)]) {
        NSArray *tabViews = [self valueForKey:@"tabViews"];
        for (id tabView in tabViews) {
            if ([tabView respondsToSelector:@selector(bh_applyCurrentThemeToIcon)]) {
                [tabView performSelector:@selector(bh_applyCurrentThemeToIcon)];
            }
        }
    }
}

- (void)dealloc {
    // if (gTabBarControllers) { // REMOVED
        // [gTabBarControllers removeObject:self]; // REMOVED
    // }
    %orig;
}

%end

// Helper: Update all tab bar icons
static void BHT_UpdateAllTabBarIcons(void) {
    // Iterate all windows and view controllers to find T1TabBarViewController
    for (UIWindow *window in UIApplication.sharedApplication.windows) {
        UIViewController *root = window.rootViewController;
        if (!root) continue;
        NSMutableArray *stack = [NSMutableArray arrayWithObject:root];
        while (stack.count > 0) {
            UIViewController *vc = [stack lastObject];
            [stack removeLastObject];
            if ([vc isKindOfClass:NSClassFromString(@"T1TabBarViewController")]) {
                NSArray *tabViews = [vc valueForKey:@"tabViews"];
                for (id tabView in tabViews) {
                    if ([tabView respondsToSelector:@selector(bh_applyCurrentThemeToIcon)]) {
                        [tabView performSelector:@selector(bh_applyCurrentThemeToIcon)];
                    }
                }
            }
            // Add children
            for (UIViewController *child in vc.childViewControllers) {
                [stack addObject:child];
            }
            if (vc.presentedViewController) {
                [stack addObject:vc.presentedViewController];
            }
        }
    }
}

static void BHT_applyThemeToWindow(UIWindow *window) {
    if (!window) return;

    // 1. Update our custom themed elements first
    // Update our custom tab bar icons
    if ([window.rootViewController isKindOfClass:NSClassFromString(@"T1TabBarViewController")]) {
        // Ensure BHT_UpdateAllTabBarIcons properly targets the tabViews of this specific window's rootVC
        // If BHT_UpdateAllTabBarIcons iterates all T1TabBarViewControllers globally, this direct call might be okay,
        // but targeting is safer if possible.
        BHT_UpdateAllTabBarIcons(); 
    }

    // Update our custom nav bar bird icon by recursively finding TFNNavigationBars
    BH_EnumerateSubviewsRecursively(window.rootViewController.view, ^(UIView *currentView) {
        if ([currentView isKindOfClass:NSClassFromString(@"TFNNavigationBar")]) {
            // updateLogoTheme should internally use BHTCurrentAccentColor()
            [(TFNNavigationBar *)currentView updateLogoTheme];
        }
    });

    // 2. Force a refresh of the currently visible content view hierarchy.
    // This is an attempt to make Twitter's own views re-evaluate the (now changed) accent color.
    UIViewController *rootVC = window.rootViewController;
    if (rootVC) {
        UIViewController *currentContentVC = rootVC;
        // Traverse to the most relevant visible content view controller
        if ([rootVC isKindOfClass:NSClassFromString(@"T1TabBarViewController")]) {
            // T1TabBarViewController is a UITabBarController subclass.
            // Cast to UITabBarController to access standard 'selectedViewController' property.
            if ([rootVC isKindOfClass:[UITabBarController class]]) {
                currentContentVC = ((UITabBarController *)rootVC).selectedViewController;
            }
        }
        
        // If the selected VC in a tab bar is a Nav controller, go to its visible VC
        if ([currentContentVC isKindOfClass:[UINavigationController class]]) {
            currentContentVC = [(UINavigationController *)currentContentVC visibleViewController];
        }

        // If we have a valid, loaded content view, tell it to redraw and re-layout.
        if (currentContentVC && currentContentVC.isViewLoaded) {
            [currentContentVC.view setNeedsDisplay];
            [currentContentVC.view setNeedsLayout];
            // Optionally, for a more immediate effect, though it can be costly if overused:
            // [currentContentVC.view layoutIfNeeded]; 
        }
    }
}

static void BHT_ensureTheming(void) {
    if (![[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) return;
    
    // Get the selected color option
    NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
    
    // Update our internal color state
    BH_changeTwitterColor(selectedOption);
    
    // Apply to Twitter's theme system
    id taeSettings = [objc_getClass("TAEColorSettings") sharedSettings];
    if ([taeSettings respondsToSelector:@selector(setPrimaryColorOption:)]) {
        [taeSettings setPrimaryColorOption:selectedOption];
    }
    
    // Notify Twitter's color system
    if ([objc_getClass("T1ColorSettings") respondsToSelector:@selector(_t1_applyPrimaryColorOption)]) {
        [objc_getClass("T1ColorSettings") _t1_applyPrimaryColorOption];
    }
    
    // Update UI elements that need specific handling
    dispatch_async(dispatch_get_main_queue(), ^{
        // Update all windows - tab bar icons need special handling
        BHT_UpdateAllTabBarIcons();
        
        // Refresh navigation bar icons
        for (UIWindow *window in [UIApplication sharedApplication].windows) {
            if (!window.isHidden && window.rootViewController) {
                BH_EnumerateSubviewsRecursively(window, ^(UIView *view) {
                    if ([view isKindOfClass:[objc_getClass("TFNNavigationBar") class]]) {
                        [(TFNNavigationBar *)view updateLogoTheme];
                    }
                });
            }
        }
    });
}

static void BHT_forceRefreshAllWindowAppearances(void) { // Renamed and logic adjusted
    // 1. Update our custom elements (these seem to work reliably)
    BHT_UpdateAllTabBarIcons(); 
    
    for (UIWindow *window in [UIApplication sharedApplication].windows) {
        if (!window.isOpaque || window.isHidden) continue; // Skip non-visible or transparent windows

        // Update our custom nav bar bird icon for this window
        if (window.rootViewController && window.rootViewController.isViewLoaded) {
            BH_EnumerateSubviewsRecursively(window.rootViewController.view, ^(UIView *currentView) {
                if ([currentView isKindOfClass:NSClassFromString(@"TFNNavigationBar")]) {
                    if ([BHTManager classicTabBarEnabled]) { // MODIFIED: Used classicTabBarEnabled
                        [(TFNNavigationBar *)currentView updateLogoTheme];
                    }
                }
            });
        }

        // Attempt to "jolt" this window's hierarchy
        UIViewController *rootVC = window.rootViewController;
        if (rootVC && rootVC.isViewLoaded) {
            BH_EnumerateSubviewsRecursively(rootVC.view, ^(UIView *subview) {
                if ([subview respondsToSelector:@selector(tintColorDidChange)]) {
                    [subview tintColorDidChange];
                }
                if ([subview respondsToSelector:@selector(setNeedsDisplay)]) {
                    [subview setNeedsDisplay]; // Force redraw
                }
            });
            [rootVC.view setNeedsLayout];
            [rootVC.view layoutIfNeeded];
            [rootVC.view setNeedsDisplay]; // Redraw the whole root view of the window
        }
    }
}

// MARK: Theme TFNBarButtonItemButtonV2
%hook TFNBarButtonItemButtonV2
- (void)didMoveToWindow {
    %orig;
    if (self.window) {
        self.tintColor = BHTCurrentAccentColor();
    }
}

- (void)setTintColor:(UIColor *)tintColor {
    %orig(BHTCurrentAccentColor());
}
%end

// MARK: - Timestamp Label Styling via UILabel -setText:

// Global reference to the timestamp label for the active immersive player
static UILabel *gVideoTimestampLabel = nil;

// Helper method to determine if a text is likely a timestamp
static BOOL isTimestampText(NSString *text) {
    if (!text || text.length == 0) {
        return NO;
    }
    
    // Check for common timestamp patterns like "0:01/0:05" or "00:20/01:30"
    NSRange colonRange = [text rangeOfString:@":"];
    NSRange slashRange = [text rangeOfString:@"/"];
    
    // Must have both colon and slash
    if (colonRange.location == NSNotFound || slashRange.location == NSNotFound) {
        return NO;
    }
    
    // Slash should come after colon in a timestamp (e.g., "0:01/0:05")
    if (slashRange.location < colonRange.location) {
        return NO;
    }
    
    // Should have another colon after the slash
    NSRange secondColonRange = [text rangeOfString:@":" options:0 range:NSMakeRange(slashRange.location, text.length - slashRange.location)];
    if (secondColonRange.location == NSNotFound) {
        return NO;
    }
    
    return YES;
}

// Helper to find player controls in view hierarchy
static UIView *findPlayerControlsInHierarchy(UIView *startView) {
    if (!startView) return nil;
    
    __block UIView *playerControls = nil;
    BH_EnumerateSubviewsRecursively(startView, ^(UIView *view) {
        if (playerControls) return;
        
        NSString *className = NSStringFromClass([view class]);
        if ([className containsString:@"PlayerControlsView"] || 
            [className containsString:@"VideoControls"]) {
            playerControls = view;
        }
    });
    
    return playerControls;
}

%hook UILabel

- (void)setText:(NSString *)text {
    %orig(text);
    
    // Skip processing if feature is disabled
    if (![BHTManager restoreVideoTimestamp]) {
        return;
    }
    
    // Skip if already our target label
    if (self == gVideoTimestampLabel) {
        return;
    }
    
    // Skip if text doesn't match timestamp pattern
    if (!isTimestampText(self.text)) {
        return;
    }
    
    // Check if already styled
    if ([objc_getAssociatedObject(self, "BHT_StyledTimestamp") boolValue]) {
        return;
    }
    
    // Find if we're in the correct view context
    UIView *parentView = self.superview;
    BOOL isInImmersiveContext = NO;
    
    while (parentView) {
        NSString *className = NSStringFromClass([parentView class]);
        if ([className isEqualToString:@"T1TwitterSwift.ImmersiveCardView"] || 
            [className hasSuffix:@".ImmersiveCardView"]) {
            isInImmersiveContext = YES;
            break;
        }
        parentView = parentView.superview;
    }
    
    if (isInImmersiveContext) {
        NSLog(@"[BHTwitter Timestamp] Styling timestamp label: %@", self.text);
        
        // Apply styling - ONLY styling, not visibility
        self.font = [UIFont systemFontOfSize:14.0];
        self.textColor = [UIColor whiteColor];
        self.textAlignment = NSTextAlignmentCenter;
        self.backgroundColor = [UIColor colorWithWhite:0.0 alpha:0.5];
        
        // Calculate size and apply padding
        [self sizeToFit];
        CGRect frame = self.frame;
        CGFloat horizontalPadding = 4.0;
        CGFloat verticalPadding = 12.0;
        
        frame = CGRectMake(
            frame.origin.x - horizontalPadding / 2.0f,
            frame.origin.y - verticalPadding / 2.0f,
            frame.size.width + horizontalPadding,
            frame.size.height + verticalPadding
        );
        
        // Ensure minimum height
        if (frame.size.height < 22.0f) {
            CGFloat diff = 22.0f - frame.size.height;
            frame.size.height = 22.0f;
            frame.origin.y -= diff / 2.0f;
        }
        
        self.frame = frame;
        self.layer.cornerRadius = frame.size.height / 2.0f;
        self.layer.masksToBounds = YES;
        
        // Mark as styled and store reference
        objc_setAssociatedObject(self, "BHT_StyledTimestamp", @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        gVideoTimestampLabel = self;
    }
}

// For first-load mode, prevent hiding the timestamp
- (void)setHidden:(BOOL)hidden {
    // Only check labels that might be our timestamp
    if (self == gVideoTimestampLabel && [BHTManager restoreVideoTimestamp]) {
        // If trying to hide a fixed label, prevent it
        if (hidden) {
            BOOL isFixedForFirstLoad = [objc_getAssociatedObject(self, "BHT_FixedForFirstLoad") boolValue];
            if (isFixedForFirstLoad) {
                // Let the original method run but with "NO" instead of "YES"
                return %orig(NO);
            }
        }
    }
    
    // Default behavior
    %orig(hidden);
}

// Also prevent changing alpha to 0 for first-load labels
- (void)setAlpha:(CGFloat)alpha {
    // Only check our timestamp label
    if (self == gVideoTimestampLabel && [BHTManager restoreVideoTimestamp]) {
        // If trying to make a fixed label transparent, prevent it
        if (alpha == 0.0) {
            BOOL isFixedForFirstLoad = [objc_getAssociatedObject(self, "BHT_FixedForFirstLoad") boolValue];
            if (isFixedForFirstLoad) {
                // Keep it fully opaque during protected period
                return %orig(1.0);
            }
        }
    }
    
    // Default behavior
    %orig(alpha);
}

%end

// MARK: Color theme
// Add a dedicated hook for Twitter's color settings class to ensure theme consistency
%hook TAEColorSettings

- (void)setPrimaryColorOption:(NSInteger)option {
    // Check if our theme is active, and ensure our value takes precedence
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
        %orig(selectedOption); // Apply our selected option instead
    } else {
        %orig; // Otherwise, let Twitter use its value
    }
}

- (void)applyCurrentColorPalette {
    %orig;
    
    // After Twitter applies its palette, ensure our theme is properly set
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
        // Update our styling but don't call orig again to avoid loops
        [self setPrimaryColorOption:selectedOption];
        BH_changeTwitterColor(selectedOption);
        // Notify Twitter color systems of the change
        if ([%c(T1ColorSettings) respondsToSelector:@selector(_t1_applyPrimaryColorOption)]) {
            [%c(T1ColorSettings) _t1_applyPrimaryColorOption];
        }
    }
}

// Intercept color changes from anywhere in the app
- (void)handleSettingsChange:(NSNotification *)notification {
    %orig;
    
    // Ensure our theme is applied after any settings change
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
            BH_changeTwitterColor(selectedOption);
        });
    }
}

%end

// Hook T1ColorSettings to ensure our changes propagate through Twitter's theme system
%hook T1ColorSettings

+ (void)_t1_applyPrimaryColorOption {
    %orig;
    
    // After Twitter applies its theme, ensure our custom tab bar styling is applied
    if ([BHTManager classicTabBarEnabled]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            BHT_UpdateAllTabBarIcons();
        });
    }
}

%end

// Simplified App Delegate hook - less redundant code, more focused
%hook T1AppDelegate
- (_Bool)application:(UIApplication *)application didFinishLaunchingWithOptions:(id)arg2 {
    %orig;
    if (![[NSUserDefaults standardUserDefaults] objectForKey:@"FirstRun_4.3"]) {
        [[NSUserDefaults standardUserDefaults] setValue:@"1strun" forKey:@"FirstRun_4.3"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"dw_v"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"hide_promoted"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"voice"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"undo_tweet"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"TrustedFriends"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"disableSensitiveTweetWarnings"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"disable_immersive_player"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"custom_voice_upload"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"dm_avatars"];
        [[NSUserDefaults standardUserDefaults] setBool:true forKey:@"tab_bar_theming"];
    }
    [BHTManager cleanCache];
    if ([BHTManager FLEX]) {
        [[%c(FLEXManager) sharedManager] showExplorer];
    }
    
    // Apply theme on launch in a cleaner, more focused way
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
        
        // Directly set the theme in TAEColorSettings
        id taeSettings = [%c(TAEColorSettings) sharedSettings];
        if ([taeSettings respondsToSelector:@selector(setPrimaryColorOption:)]) {
            [taeSettings setPrimaryColorOption:selectedOption];
        }
        
        // Also update our internal color state
        BH_changeTwitterColor(selectedOption);
        
        // Schedule a delayed refresh to ensure UI elements catch up
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            // Force T1ColorSettings to refresh
            if ([%c(T1ColorSettings) respondsToSelector:@selector(_t1_applyPrimaryColorOption)]) {
                [%c(T1ColorSettings) _t1_applyPrimaryColorOption];
            }
            
            // Update UI elements that need specific handling
            BHT_forceRefreshAllWindowAppearances();
        });
    }
    
    return true;
}

- (void)applicationDidBecomeActive:(id)arg1 {
    %orig;
    
    // Only focus on theme refresh, not additional checks
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            // Just refresh what's needed - avoid redundant checks
            BHT_ensureTheming();
        });
    }

    if ([BHTManager Padlock]) {
        NSDictionary *keychainData = [[keychain shared] getData];
        if (keychainData != nil) {
            id isAuthenticated = [keychainData valueForKey:@"isAuthenticated"];
            if (isAuthenticated == nil || [isAuthenticated isEqual:@NO]) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    AuthViewController *auth = [[AuthViewController alloc] init];
                    [auth setModalPresentationStyle:UIModalPresentationFullScreen];
                    [self.window.rootViewController presentViewController:auth animated:true completion:nil];
                });
            }
        }
    }
}

%end

// MARK: NSUserDefaults hook to protect our theme settings
%hook NSUserDefaults
- (void)setObject:(id)value forKey:(NSString *)defaultName {
    // Protect our theme color key from external changes
    if ([defaultName isEqualToString:@"T1ColorSettingsPrimaryColorOptionKey"]) {
        id selectedColor = [[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"];
        if (selectedColor != nil) {
            // Only allow setting to our chosen value
            if ([value isEqual:selectedColor]) {
                return %orig;
            } else {
                // Silently prevent changes to this key from outside
                return;
            }
        }
    }
    return %orig;
}
%end

// Improved BHT_ensureTheming to be more targeted and efficient
static void BHT_ensureTheming(void) {
    if (![[NSUserDefaults standardUserDefaults] objectForKey:@"bh_color_theme_selectedColor"]) return;
    
    // Get the selected color option
    NSInteger selectedOption = [[NSUserDefaults standardUserDefaults] integerForKey:@"bh_color_theme_selectedColor"];
    
    // Update our internal color state
    BH_changeTwitterColor(selectedOption);
    
    // Apply to Twitter's theme system
    id taeSettings = [objc_getClass("TAEColorSettings") sharedSettings];
    if ([taeSettings respondsToSelector:@selector(setPrimaryColorOption:)]) {
        [taeSettings setPrimaryColorOption:selectedOption];
    }
    
    // Notify Twitter's color system
    if ([objc_getClass("T1ColorSettings") respondsToSelector:@selector(_t1_applyPrimaryColorOption)]) {
        [objc_getClass("T1ColorSettings") _t1_applyPrimaryColorOption];
    }
    
    // Update UI elements that need specific handling
    dispatch_async(dispatch_get_main_queue(), ^{
        // Update all windows - tab bar icons need special handling
        BHT_UpdateAllTabBarIcons();
        
        // Refresh navigation bar icons
        for (UIWindow *window in [UIApplication sharedApplication].windows) {
            if (!window.isHidden && window.rootViewController) {
                BH_EnumerateSubviewsRecursively(window, ^(UIView *view) {
                    if ([view isKindOfClass:[objc_getClass("TFNNavigationBar") class]]) {
                        [(TFNNavigationBar *)view updateLogoTheme];
                    }
                });
            }
        }
    });
}

// Simplified window appearance refresh - focus on what matters
static void BHT_forceRefreshAllWindowAppearances(void) {
    // Update tab bar icons first - this is key for visual consistency
    BHT_UpdateAllTabBarIcons();
    
    for (UIWindow *window in [UIApplication sharedApplication].windows) {
        if (!window.isOpaque || window.isHidden) continue;
        
        // Focus on just the key elements that need updating
        if (window.rootViewController && window.rootViewController.isViewLoaded) {
            // Find and update navigation bars
            BH_EnumerateSubviewsRecursively(window.rootViewController.view, ^(UIView *view) {
                if ([view isKindOfClass:[objc_getClass("TFNNavigationBar") class]]) {
                    [(TFNNavigationBar *)view updateLogoTheme];
                }
            });
            
            // Force window layout refresh 
            [window.rootViewController.view setNeedsLayout];
            [window.rootViewController.view layoutIfNeeded];
        }
    }
}

